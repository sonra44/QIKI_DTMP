# План миграции Legacy → gRPC для QIKI_DTMP

## 1. Введение

Этот документ описывает пошаговый план миграции платформы QIKI_DTMP с текущей архитектуры с прямыми вызовами (Legacy) на полноценную систему, основанную на gRPC. План основан на выводах, сделанных в документе `GRPC_TECHNICAL_ANALYSIS.md`.

**Основная цель:** Создать распределенную, масштабируемую и готовую к промышленной эксплуатации архитектуру, где `q_core_agent` и `q_sim_service` взаимодействуют исключительно через gRPC.

## 2. Ключевое архитектурное решение: Централизация состояния

Миграция невозможна без изменения текущей архитектуры. **Принимается решение о централизации всего состояния в `q_sim_service`**.

- **Было:** `q_core_agent` и его компоненты частично управляют своим состоянием (BIOS, FSM).
- **Будет:** `q_sim_service` становится единственным источником правды (Single Source of Truth) для всех данных, включая **Sensors, Actuators, BIOS, FSM и Proposals**. `q_core_agent` получает все данные только от сервера.

---

## 3. Этапы миграции

### Этап 1: Достижение паритета функциональности (MVP)

**Цель:** Обеспечить, чтобы gRPC режим предоставлял тот же объем данных, что и Legacy режим, а именно добавить поддержку BIOS и FSM.

**Задачи:**

1.  **Расширение Protobuf схемы (`q_sim_api.proto`):**
    *   Добавить новые сообщения: `BiosStatus`, `FsmState`.
    *   Добавить новые RPC-методы в сервис `QSimAPI`:
        ```proto
        rpc GetBiosStatus(google.protobuf.Empty) returns (BiosStatus);
        rpc GetFsmState(google.protobuf.Empty) returns (FsmState);
        ```

2.  **Реализация на стороне сервера (`grpc_server.py` и `q_sim_service`):**
    *   Реализовать методы `GetBiosStatus` и `GetFsmState` в `QSimAPIServicer`.
    *   **Ключевая доработка:** Перенести логику генерации и управления BIOS и FSM состоянием внутрь `q_sim_service`. `grpc_server` будет лишь вызывать соответствующие методы у `q_sim_service`.

3.  **Обновление клиента (`grpc_data_provider.py`):**
    *   Удалить локальную генерацию mock-данных для BIOS.
    *   Реализовать методы `get_bios_status()` и `get_fsm_state()`, которые вызывают соответствующие gRPC эндпоинты.

**Критерий успеха:** `q_core_agent`, запущенный с флагом `--grpc`, получает корректные и актуальные данные BIOS и FSM от `q_sim_service`.

### Этап 2: Миграция расширенной функциональности (Proposals)

**Цель:** Перенести логику работы с "предложениями" (Proposals) на gRPC.

**Задачи:**

1.  **Расширение Protobuf схемы (`proposal.proto` и `q_sim_api.proto`):**
    *   Убедиться, что сообщение `Proposal` полностью определено.
    *   Добавить новые RPC-методы в `QSimAPI`:
        ```proto
        rpc GetProposals(google.protobuf.Empty) returns (stream Proposal);
        rpc SubmitProposal(Proposal) returns (ProposalAck); // ProposalAck - сообщение с подтверждением
        ```

2.  **Реализация на стороне сервера:**
    *   Добавить логику управления жизненным циклом `Proposal` в `q_sim_service`.
    *   Реализовать новые gRPC методы в `grpc_server.py`.

3.  **Обновление клиента (`grpc_data_provider.py`):**
    *   Заменить `get_proposals()`, возвращающий `[]`, на реальный вызов gRPC метода.
    *   Реализовать метод для отправки `Proposal` на сервер.

**Критерий успеха:** `q_core_agent` в gRPC режиме может успешно получать и отправлять `Proposals` на `q_sim_service`.

### Этап 3: Подготовка к промышленной эксплуатации (Production Readiness)

**Цель:** Обеспечить надежность, безопасность и наблюдаемость gRPC взаимодействия.

**Задачи:**

1.  **Надежность:**
    *   В `grpc_data_provider.py` реализовать логику автоматического переподключения к серверу с экспоненциальной задержкой (exponential backoff).
    *   Добавить таймауты для всех gRPC вызовов.

2.  **Наблюдаемость (Monitoring):**
    *   Интегрировать в `grpc_server.py` экспорт метрик в формате Prometheus (например, количество вызовов, время ответа, ошибки).
    *   Расширить `HealthCheck` для проверки доступности всех подсистем `q_sim_service`.

3.  **Безопасность:**
    *   Включить TLS шифрование для gRPC канала.
    *   Рассмотреть возможность внедрения аутентификации на основе токенов или mTLS.

**Критерий успеха:** Система стабильна, безопасна, и ее состояние можно отслеживать с помощью внешних систем мониторинга.

### Этап 4: Отказ от Legacy режима

**Цель:** Полностью удалить устаревший код прямого взаимодействия и оставить gRPC как единственный способ коммуникации.

**Задачи:**

1.  **Рефакторинг `main.py`:**
    *   Удалить флаг `--grpc`.
    *   `GrpcDataProvider` становится провайдером данных по умолчанию.

2.  **Удаление кода:**
    *   Удалить старый `QSimDataProvider`.
    *   Вычистить весь связанный код, который использовался только в Legacy режиме.

**Критерий успеха:** Кодовая база упрощена, содержит только gRPC архитектуру, что снижает сложность поддержки.

---

## 4. Риски и их минимизация

- **Риск:** Перенос логики управления состоянием в `q_sim_service` является сложной задачей и может привести к появлению регрессионных ошибок.
- **Минимизация:**
    1.  Перед началом миграции разработать полный набор модульных тестов для текущей логики BIOS, FSM и Proposals.
    2.  Проводить миграцию по одному компоненту за раз (сначала BIOS, потом FSM, и т.д.), на каждом шаге прогоняя все тесты.
    3.  Провести полное интеграционное тестирование после каждого этапа миграции.
