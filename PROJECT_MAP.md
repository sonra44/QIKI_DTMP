# Карта проекта QIKI_DTMP

Этот документ содержит детальный анализ файлов и кода в проекте QIKI_DTMP.

---

## Файл: `/home/sonra44/QIKI_DTMP/run_gemini_auto.sh`

**Тип:** Исполняемый скрипт (Shell Script)

**Назначение:**
Этот скрипт предназначен для полностью автономного запуска Gemini CLI с заранее определенной задачей. Его ключевая особенность — автоматический ввод подтверждений («yes», «да», «continue» и т.д.), чтобы обойти любые интерактивные запросы от Gemini.

**Логика работы:**
1.  **Определение задачи:** Скрипт формулирует сложную задачу для Gemini, которая включает запуск демо-скрипта, анализ логов и создание отчета.
2.  **Автоответчик:** Создается список стандартных положительных ответов.
3.  **Временный файл:** Ответы записываются во временный файл в `/tmp/`.
4.  **Запуск Gemini:** Gemini запускается с основной задачей (`gemini -p "$TASK"`). В стандартный ввод команды (`stdin`) передается содержимое временного файла с ответами, что и обеспечивает автоматизацию. Процесс запускается в фоновом режиме с таймаутом в 300 секунд.
5.  **Мониторинг:** Скрипт отслеживает запущенный процесс Gemini и сообщает о его работе каждые 10 секунд.
6.  **Завершение и очистка:** После завершения работы Gemini временный файл с ответами удаляется.
7.  **Проверка результата:** Скрипт проверяет, был ли создан итоговый файл `gemini_report.txt`, и сообщает о результате.

**Ключевые команды:**
-   `timeout`: Ограничивает время выполнения команды.
-   `gemini -p "..."`: Запускает Gemini с текстовым промтом.
-   `< "$ANSWERS_FILE"`: Перенаправляет содержимое файла в стандартный ввод команды.
-   `&`: Запускает команду в фоновом режиме.
-   `$!`: Получает PID последнего фонового процесса.
-   `kill -0 "$PID"`: Проверяет, существует ли процесс с данным PID.

---

## Файл: `/home/sonra44/QIKI_DTMP/services/q_core_agent/core/agent.py`

**Тип:** Модуль Python

**Назначение:**
Этот файл является ядром агента (`QCoreAgent`). Он выполняет роль центрального «мозга», который координирует работу всех остальных компонентов: получает данные, обрабатывает их, принимает решения и управляет действиями «бота».

**Ключевые классы:**
-   `AgentContext`: Класс для хранения состояния агента в рамках одного цикла обработки («тика»). Содержит статус BIOS, состояние конечного автомата (FSM) и предложения от движков принятия решений.
-   `QCoreAgent`: Основной класс, который инициализирует и объединяет все компоненты агента.

**Компоненты и архитектура:**
-   **`TickOrchestrator`**: Управляет главным циклом работы агента (`run_tick`).
-   **`IDataProvider`**: Интерфейс для получения данных из внешнего мира (например, от симулятора).
-   **Обработчики (`Handlers`)**:
    -   `BiosHandler`: Обрабатывает статус базовой системы ввода-вывода (BIOS).
    -   `FSMHandler`: Управляет состоянием конечного автомата (например, «загрузка», «ожидание», «работа»).
-   **Движки предложений (`Engines`)**:
    -   `RuleEngine`: Генерирует предложения о действиях на основе жестко заданных правил.
    -   `NeuralEngine`: Генерирует предложения с помощью нейросети.
-   **`ProposalEvaluator`**: Оценивает и выбирает лучшие предложения от движков.
-   **`BotCore`**: Низкоуровневый интерфейс для отправки команд исполнительным механизмам («актюаторам») бота.

**Логика работы (внутри одного «тика»):**
1.  **Обновление контекста**: `QCoreAgent` получает свежие данные через `IDataProvider`.
2.  **Обработка состояния**: Последовательно вызываются обработчики для BIOS и FSM.
3.  **Генерация предложений**: `RuleEngine` и `NeuralEngine` создают возможные варианты действий.
4.  **Принятие решения**: `ProposalEvaluator` выбирает лучшее предложение, и `QCoreAgent` отдает команду на его выполнение через `BotCore`.

**Особенности:**
-   **Отказоустойчивость**: При сбое в одном из обработчиков агент переключается в безопасный режим (`_switch_to_safe_mode`).
-   **Protobuf**: Используются классы, сгенерированные из `.proto` файлов, что указывает на применение gRPC для обмена данными.
-   **Интерфейсы**: Код активно использует интерфейсы (`IDataProvider`, `IBiosHandler` и т.д.), что делает систему более гибкой и тестируемой.

---

## Файл: `/home/sonra44/QIKI_DTMP/services/q_core_agent/core/grpc_data_provider.py`

**Тип:** Модуль Python

**Назначение:**
Реализует интерфейс `IDataProvider`. Этот класс отвечает за сетевое взаимодействие с сервисом-симулятором (`Q-Sim Service`) по протоколу gRPC. Он позволяет агенту и симулятору работать как два независимых процесса.

**Ключевой класс:**
-   `GrpcDataProvider`: Основной класс, управляющий gRPC-клиентом.

**Логика работы:**
1.  **Соединение (`_connect`)**: При инициализации устанавливает gRPC-соединение с сервером по адресу `localhost:50051`. Включает проверку работоспособности (`HealthCheck`) сервера.
2.  **Получение данных (`get_...`)**: 
    -   `get_sensor_data()`: Выполняет удаленный вызов процедуры `GetSensorData` на gRPC-сервере для получения данных с сенсоров. Это основная функция получения реальных данных.
    -   `get_bios_status()`, `get_fsm_state()`, `get_proposals()`: Эти методы **не делают gRPC-запрос**, а возвращают **заглушки (mocks)**. Комментарии в коде поясняют, что симулятор не отвечает за эти данные, поэтому здесь генерируются правдоподобные, но не реальные ответы.
3.  **Отправка команд (`send_actuator_command`)**: Выполняет удаленный вызов процедуры `SendActuatorCommand` на gRPC-сервере, передавая ей команду для исполнительного механизма.

**Особенности:**
-   **gRPC-клиент**: Является клиентом для `QSimAPIStub`, сгенерированного из proto-файлов.
-   **Отказоустойчивость**: Все gRPC-вызовы обернуты в блоки `try...except` для обработки ошибок сети или недоступности сервера.
-   **Разделение логики**: Четко отделяет логику получения данных от логики их обработки в `QCoreAgent`. Часть данных реальна (сенсоры), часть — имитируется (BIOS, FSM), что важно для понимания потока данных в системе.

---

## Файл: `/home/sonra44/QIKI_DTMP/services/q_core_agent/core/interfaces.py`

**Тип:** Модуль Python

**Назначение:**
Это ключевой архитектурный файл, определяющий «контракты» для всех основных компонентов системы с помощью абстрактных базовых классов (интерфейсов). Такой подход (Dependency Inversion Principle) отделяет основную логику агента от конкретных реализаций его частей, делая систему модульной, гибкой и легко тестируемой.

**Абстрактные интерфейсы:**
-   `IDataProvider`: Определяет, как агент получает данные и отправляет команды. Любой поставщик данных (реальный, тестовый, сетевой) должен реализовать этот интерфейс.
-   `IBiosHandler`: Определяет, как обрабатывать отчеты BIOS.
-   `IFSMHandler`: Определяет, как обрабатывать состояния конечного автомата.
-   `IProposalEvaluator`: Определяет, как оценивать и фильтровать предложения.
-   `IRuleEngine`: Интерфейс для движка, генерирующего предложения по правилам.
-   `INeuralEngine`: Интерфейс для движка, генерирующего предложения с помощью ML-моделей.

**Конкретные реализации в этом файле:**
-   `MockDataProvider`: Реализация `IDataProvider` для тестов. Возвращает заранее заданные, «поддельные» данные. Позволяет тестировать логику агента в изоляции, без запуска всего симулятора.
-   `QSimDataProvider`: Еще одна реализация `IDataProvider`, которая напрямую обращается к объекту симулятора (`QSimService`). Предназначена для сценариев, когда агент и симулятор работают в одном процессе.

**Архитектурная значимость:**
-   **Гибкость**: `QCoreAgent` не зависит от того, откуда приходят данные — из gRPC, прямого вызова или мок-объекта. Это позволяет легко переключать конфигурации (например, с локального тестирования на распределенное).
-   **Тестируемость**: Наличие `MockDataProvider` и интерфейсов — основа для надежного юнит-тестирования каждого компонента системы по отдельности.

---

## Файл: `/home/sonra44/QIKI_DTMP/services/q_core_agent/main.py`

**Тип:** Исполняемый файл (точка входа)

**Назначение:**
Главный скрипт для запуска `QCoreAgent`. Он отвечает за инициализацию, конфигурацию и запуск основного цикла работы агента. Позволяет запускать агент в различных режимах.

**Ключевые функции:**
-   **Парсинг аргументов**: Использует `argparse` для определения режима запуска:
    -   `--mock`: Режим для тестирования, использует `MockDataProvider` с заранее подготовленными данными.
    -   `--grpc`: Режим для работы с симулятором по сети, использует `GrpcDataProvider`.
    -   **По умолчанию (Legacy)**: Режим прямого взаимодействия с симулятором в одном процессе, использует `QSimDataProvider`.
-   **Загрузка конфигурации**: Читает настройки из `config.yaml` и `config/logging.yaml`.
-   **Инициализация компонентов**: Создает и связывает все необходимые объекты: `QCoreAgent`, `TickOrchestrator` и нужный `DataProvider` в зависимости от режима.
-   **Интеграция с `StateStore`**: Проверяет переменную окружения `QIKI_USE_STATESTORE`. Если она установлена, агент переключается в асинхронный режим с использованием персистентного хранилища состояний, что является более продвинутой функцией.
-   **Основной цикл**: Содержит бесконечный цикл (`while True`), который вызывает `orchestrator.run_tick()` и делает паузу. Для режима со `StateStore` используется асинхронный цикл `asyncio`.
-   **Корректное завершение**: Перехватывает сигналы `SIGINT` (Ctrl+C) и `SIGTERM` для безопасной остановки агента.

**Архитектурная значимость:**
-   Является «сборочным цехом» для всего сервиса агента.
-   Обеспечивает гибкость запуска и конфигурации, позволяя легко переключаться между тестовым, локальным и распределенным режимами работы.

---

## Файл: `/home/sonra44/QIKI_DTMP/scripts/hot_test_statestore.sh`

**Тип:** Исполняемый скрипт (Shell Script)

**Назначение:**
Комплексный «горячий тест» для проверки качества и надежности компонента `StateStore`. Скрипт автоматизирует полный цикл тестирования: от проверки синтаксиса до стресс-тестов и генерации отчета.

**Структура и логика работы:**
-   **Модульность**: Скрипт разбит на функции, каждая из которых отвечает за свой этап проверки (`check_environment`, `run_unit_tests`, `functional_test` и т.д.).
-   **Последовательность тестов**: Проверки выполняются в порядке возрастания сложности:
    1.  **Проверка окружения и синтаксиса**: Базовые проверки на наличие зависимостей и корректность кода.
    2.  **Unit-тесты**: Запуск `pytest` для отдельных модулей `StateStore`.
    3.  **Integration-тесты**: Проверка взаимодействия компонентов `StateStore`.
    4.  **Functional-тесты**: Генерация временного Python-скрипта для проверки полной цепочки операций (создание, запись, чтение, подписка).
    5.  **Performance-тесты**: Генерация Python-скрипта для замера производительности (операций в секунду).
    6.  **Memory Leak-тесты**: Продвинутый тест, который создает и удаляет множество объектов, отслеживая рост мусора в памяти (`gc.get_objects()`) для выявления утечек.
-   **Генерация отчета**: В конце успешного выполнения создает Markdown-файл (`HOT_TEST_REPORT_...md`) с результатами и рекомендациями.
-   **Гибкость запуска**: Поддерживает флаги (`--unit-only`, `--quick`) для запуска только определенных частей теста.

**Архитектурная значимость:**
-   Демонстрирует зрелый подход к обеспечению качества критически важного компонента (`StateStore`).
-   Использование самогенерируемых Python-скриптов внутри shell-скрипта — мощный прием для выполнения сложных, самодостаточных тестов.
-   Является отличным примером автоматизированного конвейера для проверки качества кода.

---

## Файл: `/home/sonra44/QIKI_DTMP/services/q_core_agent/state/tests/test_stress.py`

**Тип:** Модуль тестов Python (`pytest`)

**Назначение:**
Этот файл содержит набор стресс-тестов для компонента `StateStore`. Цель этих тестов — проверить производительность, стабильность и корректность работы `StateStore` в условиях экстремальных нагрузок, таких как высокая частота операций, одновременный доступ из многих потоков и нехватка памяти.

**Ключевые виды тестов:**
-   **Тесты на объем (`High Volume`)**: Проверяют способность системы обрабатывать тысячи операций чтения/записи и обслуживать сотни подписчиков без сбоев.
-   **Тесты на конкурентный доступ (`Concurrency Stress`)**: 
    -   `test_concurrent_writers_stress`: Множество «писателей» одновременно пытаются изменить состояние, проверяя наличие гонок данных и блокировок.
    -   `test_mixed_operations_chaos`: Создает хаотичную среду, где одновременно работают «писатели», «читатели» и «подписчики», имитируя реальную нагрузку.
    -   `test_subscriber_stress_with_backpressure`: Сложный тест, проверяющий, что «медленные» подписчики не тормозят всю систему и не приводят к потере данных для «быстрых».
-   **Тесты на использование памяти (`Memory Stress`)**: 
    -   `test_memory_pressure_large_snapshots`: Проверяет, как система работает при сохранении очень больших объектов.
    -   `test_subscriber_memory_cleanup`: Проверяет, не происходит ли утечек памяти при массовом создании и удалении подписчиков.
-   **Тесты стабильности и производительности (`Long Running`, `Benchmarks`)**: Проверяют, что система остается стабильной при длительной работе, и измеряют ключевые метрики производительности (операций/сек, задержка).

**Архитектурная значимость:**
-   Наличие такого набора тестов свидетельствует о том, что `StateStore` является критически важным компонентом, который должен быть чрезвычайно надежным и производительным.
-   Показывает глубокое понимание проблем, связанных с асинхронными и многопоточными системами (гонки данных, блокировки, утечки памяти).
-   Гарантирует, что компонент готов к использованию в production-среде.

---

## Файл: `/home/sonra44/QIKI_DTMP/services/q_core_agent/state/tests/test_integration.py`

**Тип:** Модуль тестов Python (`pytest`)

**Назначение:**
Содержит интеграционные тесты для архитектуры `StateStore`. В отличие от unit-тестов, они проверяют корректность взаимодействия нескольких компонентов системы друг с другом: `FSMHandler`, `StateStore`, конвертеры данных и система подписок.

**Ключевые сценарии тестирования:**
-   **`FSMHandler + StateStore`**: Основной тест, который проверяет, что при обработке состояния в `FSMHandler` результат корректно сохраняется в `StateStore`, а версия состояния монотонно возрастает.
-   **`StateStore + Subscribers`**: Проверяет, что при изменении состояния в `StateStore` все подписчики немедленно получают уведомление с актуальными данными.
-   **`Converters + Real Data`**: Тестирует, что функции конвертации (`dto_to_proto`, `proto_to_dto`, `dto_to_json_dict`) корректно работают с реальными объектами состояния, которые были созданы в ходе FSM-переходов, и не теряют данные.
-   **`Concurrent Access`**: Имитирует одновременную работу нескольких обработчиков FSM и подписчиков, чтобы убедиться, что система остается консистентной и не возникает гонок данных.
-   **`Error Handling`**: Проверяет устойчивость системы к сбоям. Например, что сбой одного «плохого» подписчика не влияет на работу остальных, или что система не падает, если `StateStore` временно недоступен.

**Архитектурная значимость:**
-   Эти тесты доказывают, что архитектура `StateStore` не просто работает на уровне отдельных функций, а является надежной и предсказуемой системой.
-   Использование «моков» (`MockFSMHandler`) для имитации реальных компонентов в тестах — это хороший пример гибкости, достигнутой благодаря следованию принципам SOLID (в частности, инверсии зависимостей).
-   Тестирование сложных сценариев взаимодействия (конкурентный доступ, изоляция ошибок) является залогом создания отказоустойчивого программного обеспечения.

---

## Файл: `/home/sonra44/QIKI_DTMP/services/q_core_agent/state/tests/test_conv.py`

**Тип:** Модуль тестов Python (`pytest`)

**Назначение:**
Содержит unit-тесты для модуля конвертации (`conv.py`). Цель — гарантировать, что преобразование между внутренними объектами данных (DTO) и внешними (Protobuf) происходит абсолютно точно, без потерь и с корректной обработкой ошибок.

**Ключевые сценарии тестирования:**
-   **`TestEnumMappings`**: Проверяет, что перечисления (`Enum`), такие как `FsmState`, корректно отображаются на их Protobuf-эквиваленты (`FSMStateEnum`) и обратно.
-   **`TestSnapshotConversion`**: Основной тест, проверяющий полную конвертацию главного объекта состояния `FsmSnapshotDTO` в `FsmStateSnapshot` (Protobuf) и обратно. Особое внимание уделяется сложным полям, таким как история переходов и словари с метаданными.
-   **`test_roundtrip_conversion`**: Главный тест, который выполняет полный цикл `DTO -> Proto -> DTO` и проверяет, что итоговый объект идентичен исходному.
-   **`TestConversionErrors`**: Тестирует, как система обрабатывает некорректные данные: неизвестные значения `enum`, невалидные UUID и т.д.
-   **`TestJSONConversion`**: Проверяет корректность конвертации DTO в JSON-формат, который используется для логирования и отладки.
-   **`TestEdgeCasesAndBoundaries`**: Тестирует граничные случаи: очень большие числа, строки с Unicode-символами (включая разные языки), пустые и очень большие списки/словари.

**Архитектурная значимость:**
-   Показывает скрупулезный подход к разработке. Корректная сериализация/десериализация данных — критически важный аспект надежности распределенных систем.
-   Тестирование не только «счастливого пути», но и множества ошибок и граничных случаев, является признаком зрелого, защитного программирования.
-   Подтверждает правильность архитектурного решения о разделении внутреннего (DTO) и внешнего (Protobuf) представления данных, гарантируя, что «мост» между ними надежен.

---

## Файл: `/home/sonra44/QIKI_DTMP/services/q_core_agent/state/tests/test_store.py`

**Тип:** Модуль тестов Python (`pytest`)

**Назначение:**
Содержит unit-тесты для самого класса `AsyncStateStore`. Цель — проверить, что ключевые функции хранилища (запись, чтение, версионирование, система подписок) работают корректно и надежно в изоляции от остальной системы.

**Ключевые сценарии тестирования:**
-   **Базовые операции**: Проверяется корректность `set()` и `get()`, а также поведение при работе с пустым хранилищем.
-   **Версионирование**: Тестируется автоматическое увеличение версии при каждой записи (`set`) и принудительная проверка версии (`enforce_version=True`) для предотвращения гонок данных.
-   **Система подписок (Pub/Sub)**:
    -   Проверяется, что новый подписчик сразу получает текущее состояние.
    -   Гарантируется, что все подписчики получают обновления при изменении состояния.
    -   Тестируется отписка (`unsubscribe`) и автоматическая очистка «мертвых» подписчиков.
-   **Конкурентный доступ**: Очень важная часть тестов, которая имитирует одновременный доступ к хранилищу из разных частей программы (`asyncio.gather`). Проверяется, что блокировки (`lock`) работают корректно и не приводят к повреждению данных.
-   **Метрики и Health Check**: Тестируется, что внутренние метрики (счетчики операций, конфликтов версий) и проверка «здоровья» (`health_check`) работают правильно.

**Архитектурная значимость:**
-   Этот файл доказывает надежность `AsyncStateStore` — центрального компонента всей архитектуры управления состоянием.
-   Тщательное тестирование конкурентного доступа и механизма подписок абсолютно необходимо для создания стабильного, событийно-ориентированного приложения.
-   Тесты подтверждают, что хранилище спроектировано с учетом предотвращения классических проблем управления состоянием, таких как потерянные обновления и гонки данных.

---

## Файл: `/home/sonra44/QIKI_DTMP/services/q_core_agent/state/tests/test_types.py`

**Тип:** Модуль тестов Python (`pytest`)

**Назначение:**
Содержит unit-тесты для основных структур данных (`DTOs`), определенных в `types.py`. Цель — гарантировать, что эти объекты создаются корректно, являются неизменяемыми (`immutable`), и что вспомогательные функции для их создания и обновления работают предсказуемо.

**Ключевые сценарии тестирования:**
-   **Неизменяемость (`Immutability`)**: Самый важный тест в этом файле. С помощью `pytest.raises(FrozenInstanceError)` проверяется, что после создания объекта `FsmSnapshotDTO` или `TransitionDTO` его атрибуты нельзя изменить. Это ключевое архитектурное решение для предсказуемого управления состоянием.
-   **Корректность создания**: Тесты проверяют, что объекты создаются с правильными значениями по умолчанию, а также с переданными параметрами.
-   **Тестирование `next_snapshot()`**: Это ключевая функция для изменения состояния. Тесты проверяют, что:
    -   Версия корректно увеличивается только при реальном изменении состояния.
    -   Версия НЕ меняется, если состояние не изменилось.
    -   История переходов (`history`) правильно пополняется.
    -   Важные метаданные (например, `fsm_instance_id`) сохраняются между состояниями.
-   **Тестирование граничных случаев**: Проверяется работа с пустыми строками, `None`, большими коллекциями и Unicode-символами.

**Архитектурная значимость:**
-   Эти тесты — фундамент всей системы состояний. Они обеспечивают выполнение главного принципа — **неизменяемости (immutability)**. Это предотвращает огромное количество потенциальных ошибок, когда разные части программы могли бы случайно изменить один и тот же объект состояния.
-   Тесты для `initial_snapshot()` и `next_snapshot()` подтверждают использование паттерна «Фабрика» для создания состояний, что делает API для управления состоянием более безопасным и предсказуемым.
-   Вместе с другими файлами тестов (`test_store`, `test_conv`, `test_integration`) этот файл демонстрирует многоуровневую стратегию тестирования: от базовых типов данных до их хранения, сериализации и совместной работы.

---

## Файл: `/home/sonra44/QIKI_DTMP/services/q_core_agent/state/tests/__init__.py`

**Тип:** Инициализатор пакета Python

**Назначение:**
Этот файл маркирует директорию `tests` как пакет Python, что позволяет импортировать из нее модули. Комментарии в файле также служат кратким оглавлением, описывая назначение каждого тестового модуля в пакете.

**Архитектурная значимость:**
-   Стандартная практика в Python для организации кода в виде пакетов.
-   Помогает в навигации и понимании структуры тестового набора.

---

## Файл: `/home/sonra44/QIKI_DTMP/services/q_core_agent/core/tick_orchestrator.py`

**Тип:** Модуль Python

**Назначение:**
Определяет класс `TickOrchestrator`, который управляет основным циклом («тиком») работы агента. Он выступает в роли «дирижера», который обеспечивает последовательное выполнение всех фаз обработки данных, а также добавляет логирование и обработку ошибок.

**Ключевые функции:**
-   **Два режима работы**: Оркестратор может работать в двух режимах в зависимости от переменной окружения `QIKI_USE_STATESTORE`:
    1.  **Асинхронный (`run_tick_async`)**: Основной режим, который использует `AsyncStateStore` для управления состоянием. Это позволяет отделить логику конечного автомата от поставщика данных.
    2.  **Синхронный (`run_tick`)**: Устаревший режим для обратной совместимости, где состояние получается напрямую от поставщика данных.
-   **Структурированное логирование**: В конце каждого «тика» записывается подробная информация, включая длительность каждой фазы (обновление контекста, обработка BIOS, FSM и т.д.), что крайне полезно для отладки и профилирования производительности.
-   **Обработка ошибок**: Весь цикл обернут в `try...except`, что позволяет перехватывать сбои на любом этапе, переводить агент в безопасный режим (`_switch_to_safe_mode`) и избегать полного падения сервиса.

**Архитектурная значимость:**
-   Четко разделяет логику агента (ЧТО делать) от управления жизненным циклом (КОГДА и в КАКОМ ПОРЯДКЕ это делать).
-   Наличие двух режимов работы является ярким признаком эволюции архитектуры — перехода от простой модели состояний к более надежной, персистентной модели на основе `StateStore`.
-   Детальное логирование производительности указывает на зрелый подход к разработке и ориентацию на стабильную работу в production-среде.

---

## Файл: `/home/sonra44/QIKI_DTMP/services/q_core_agent/core/fsm_handler.py`

**Тип:** Модуль Python

**Назначение:**
Реализует интерфейс `IFSMHandler`. Этот класс отвечает за логику переходов конечного автомата (FSM). Он принимает текущее состояние, анализирует условия (статус BIOS, наличие предложений) и определяет следующее состояние агента.

**Ключевые функции:**
-   **Два режима работы**: Как и оркестратор, обработчик FSM имеет два метода, отражающих эволюцию архитектуры:
    1.  **`process_fsm_dto` (Асинхронный)**: Современный метод, работающий с неизменяемыми DTO. Он вычисляет следующее состояние и записывает его в `StateStore`, выступая единственным «писателем» состояний FSM.
    2.  **`process_fsm_state` (Синхронный)**: Устаревший метод для обратной совместимости, работающий напрямую с изменяемыми объектами Protobuf.
-   **Логика переходов (`_compute_transition_dto`)**: Вся логика принятия решений о смене состояний инкапсулирована в одном методе. Правила переходов четко определены:
    -   `BOOTING` -> `IDLE` (если BIOS в порядке).
    -   `IDLE` -> `ACTIVE` (если появились предложения).
    -   `ACTIVE` -> `IDLE` (если предложения закончились).
    -   Любое состояние -> `ERROR_STATE` (если BIOS не в порядке).
-   **Интеграция со `StateStore`**: Является основным «клиентом» для `StateStore`, вызывая `state_store.set()` для сохранения нового состояния, что, в свою очередь, уведомляет всех подписчиков.

**Архитектурная значимость:**
-   Является «хранителем» логики состояний агента. Это единственное место, где определены правила переходов, что упрощает понимание и изменение поведения FSM.
-   Четкое разделение логики вычисления нового состояния (`_compute_transition_dto`) от его сохранения (`state_store.set()`) является хорошим примером принципа единственной ответственности.

---

## Файл: `/home/sonra44/QIKI_DTMP/services/q_core_agent/state/conv.py`

**Тип:** Модуль Python (Конвертер)

**Назначение:**
Этот модуль является «переводчиком» между двумя представлениями данных о состоянии: внутренним (объекты DTO, удобные для Python) и внешним (объекты Protobuf, для межсервисного взаимодействия). Он изолирует логику сериализации/десериализации от основной бизнес-логики.

**Ключевые функции:**
-   **`dto_to_proto` / `proto_to_dto`**: Основные функции, которые выполняют полное преобразование между `FsmSnapshotDTO` и `FsmStateSnapshot` (Protobuf).
-   **Сохранение метаданных**: Оригинально решена проблема расхождения моделей: поля, которые есть в DTO, но отсутствуют в Protobuf (например, `version`, `reason`), упаковываются в словарь `state_metadata` в Protobuf-сообщении. Это позволяет совершать `DTO -> Proto -> DTO` преобразование без потерь.
-   **Конвертация в JSON**: Предоставляет два способа сериализации в JSON: `dto_to_json_dict` (облегченный, для логов) и `dto_to_protobuf_json` (полный, для совместимости).
-   **Обработка ошибок**: Определяет собственное исключение `ConversionError` для инкапсуляции ошибок преобразования.

**Архитектурная значимость:**
-   Является реализацией паттерна **Адаптер (Adapter)** или **Слой-антикоррупционер (Anti-Corruption Layer)**. Он защищает ядро системы от деталей внешнего формата данных.
-   Благодаря этому модулю, если в будущем потребуется перейти с Protobuf на другой формат, изменения коснутся только этого файла, а остальная часть системы, работающая с DTO, останется неизменной.

---

## Файл: `/home/sonra44/QIKI_DTMP/services/q_core_agent/state/store.py`

**Тип:** Модуль Python

**Назначение:**
Определяет `AsyncStateStore` — центральное, потокобезопасное, асинхронное хранилище для состояния конечного автомата (FSM). Является «Единственным источником правды» (Single Source of Truth) для состояния, обеспечивая консистентность данных во всем приложении.

**Ключевые функции:**
-   **Потокобезопасность**: Все операции чтения и записи защищены `asyncio.Lock()`, что гарантирует отсутствие гонок данных при одновременном доступе.
-   **Версионирование**: Автоматически увеличивает версию состояния при каждом изменении, что позволяет отслеживать историю и предотвращать запись устаревших данных.
-   **Система подписок (Pub/Sub)**: Через `subscribe()` любой компонент может подписаться на обновления состояния. При каждом вызове `set()` все подписчики получают уведомление с новым состоянием через `asyncio.Queue`.
-   **Отказоустойчивость**: Система уведомлений спроектирована так, что один «медленный» или «мертвый» подписчик не может заблокировать или сломать всю систему.
-   **Метрики и мониторинг**: Собирает внутреннюю статистику по операциям и предоставляет метод `health_check()` для самодиагностики.

**Архитектурная значимость:**
-   Это сердце новой архитектуры управления состоянием. Реализует паттерн «in-memory database» с возможностями Pub/Sub.
-   Сочетание блокировок, неизменяемых объектов (DTO) и версионирования делает этот компонент чрезвычайно надежным и устойчивым к проблемам, характерным для многопоточных/асинхронных приложений.
-   Модель Pub/Sub позволяет строить остальную часть системы по принципам событийно-ориентированного программирования, где компоненты реагируют на изменения, а не постоянно опрашивают состояние.

---

## Файл: `/home/sonra44/QIKI_DTMP/services/q_core_agent/state/conv.py`

**Тип:** Модуль Python (Конвертер)

**Назначение:**
Этот модуль является «переводчиком» между двумя представлениями данных о состоянии: внутренним (объекты DTO, удобные для Python) и внешним (объекты Protobuf, для межсервисного взаимодействия). Он изолирует логику сериализации/десериализации от основной бизнес-логики.

**Ключевые функции:**
-   **`dto_to_proto` / `proto_to_dto`**: Основные функции, которые выполняют полное преобразование между `FsmSnapshotDTO` и `FsmStateSnapshot` (Protobuf).
-   **Сохранение метаданных**: Оригинально решена проблема расхождения моделей: поля, которые есть в DTO, но отсутствуют в Protobuf (например, `version`, `reason`), упаковываются в словарь `state_metadata` в Protobuf-сообщении. Это позволяет совершать `DTO -> Proto -> DTO` преобразование без потерь.
-   **Конвертация в JSON**: Предоставляет два способа сериализации в JSON: `dto_to_json_dict` (облегченный, для логов) и `dto_to_protobuf_json` (полный, для совместимости).
-   **Обработка ошибок**: Определяет собственное исключение `ConversionError` для инкапсуляции ошибок преобразования.

**Архитектурная значимость:**
-   Является реализацией паттерна **Адаптер (Adapter)** или **Слой-антикоррупционер (Anti-Corruption Layer)**. Он защищает ядро системы от деталей внешнего формата данных.
-   Благодаря этому модулю, если в будущем потребуется перейти с Protobuf на другой формат, изменения коснутся только этого файла, а остальная часть системы, работающая с DTO, останется неизменной.

---

## Файл: `/home/sonra44/QIKI_DTMP/services/q_core_agent/core/fsm_handler.py`

**Тип:** Модуль Python

**Назначение:**
Реализует интерфейс `IFSMHandler`. Этот класс отвечает за логику переходов конечного автомата (FSM). Он принимает текущее состояние, анализирует условия (статус BIOS, наличие предложений) и определяет следующее состояние агента.

**Ключевые функции:**
-   **Два режима работы**: Как и оркестратор, обработчик FSM имеет два метода, отражающих эволюцию архитектуры:
    1.  **`process_fsm_dto` (Асинхронный)**: Современный метод, работающий с неизменяемыми DTO. Он вычисляет следующее состояние и записывает его в `StateStore`, выступая единственным «писателем» состояний FSM.
    2.  **`process_fsm_state` (Синхронный)**: Устаревший метод для обратной совместимости, работающий напрямую с изменяемыми объектами Protobuf.
-   **Логика переходов (`_compute_transition_dto`)**: Вся логика принятия решений о смене состояний инкапсулирована в одном методе. Правила переходов четко определены:
    -   `BOOTING` -> `IDLE` (если BIOS в порядке).
    -   `IDLE` -> `ACTIVE` (если появились предложения).
    -   `ACTIVE` -> `IDLE` (если предложения закончились).
    -   Любое состояние -> `ERROR_STATE` (если BIOS не в порядке).
-   **Интеграция со `StateStore`**: Является основным «клиентом» для `StateStore`, вызывая `state_store.set()` для сохранения нового состояния, что, в свою очередь, уведомляет всех подписчиков.

**Архитектурная значимость:**
-   Является «хранителем» логики состояний агента. Это единственное место, где определены правила переходов, что упрощает понимание и изменение поведения FSM.
-   Четкое разделение логики вычисления нового состояния (`_compute_transition_dto`) от его сохранения (`state_store.set()`) является хорошим примером принципа единственной ответственности.

---

## Файл: `/home/sonra44/QIKI_DTMP/services/q_core_agent/state/tests/__init__.py`

**Тип:** Инициализатор пакета Python

**Назначение:**
Этот файл маркирует директорию `tests` как пакет Python, что позволяет импортировать из нее модули. Комментарии в файле также служат кратким оглавлением, описывая назначение каждого тестового модуля в пакете.

**Архитектурная значимость:**
-   Стандартная практика в Python для организации кода в виде пакетов.
-   Помогает в навигации и понимании структуры тестового набора.

---

## Файл: `/home/sonra44/QIKI_DTMP/services/q_core_agent/core/tick_orchestrator.py`

**Тип:** Модуль Python

**Назначение:**
Определяет класс `TickOrchestrator`, который управляет основным циклом («тиком») работы агента. Он выступает в роли «дирижера», который обеспечивает последовательное выполнение всех фаз обработки данных, а также добавляет логирование и обработку ошибок.

**Ключевые функции:**
-   **Два режима работы**: Оркестратор может работать в двух режимах в зависимости от переменной окружения `QIKI_USE_STATESTORE`:
    1.  **Асинхронный (`run_tick_async`)**: Основной режим, который использует `AsyncStateStore` для управления состоянием. Это позволяет отделить логику конечного автомата от поставщика данных.
    2.  **Синхронный (`run_tick`)**: Устаревший режим для обратной совместимости, где состояние получается напрямую от поставщика данных.
-   **Структурированное логирование**: В конце каждого «тика» записывается подробная информация, включая длительность каждой фазы (обновление контекста, обработка BIOS, FSM и т.д.), что крайне полезно для отладки и профилирования производительности.
-   **Обработка ошибок**: Весь цикл обернут в `try...except`, что позволяет перехватывать сбои на любом этапе, переводить агент в безопасный режим (`_switch_to_safe_mode`) и избегать полного падения сервиса.

**Архитектурная значимость:**
-   Четко разделяет логику агента (ЧТО делать) от управления жизненным циклом (КОГДА и в КАКОМ ПОРЯДКЕ это делать).
-   Наличие двух режимов работы является ярким признаком эволюции архитектуры — перехода от простой модели состояний к более надежной, персистентной модели на основе `StateStore`.
-   Детальное логирование производительности указывает на зрелый подход к разработке и ориентацию на стабильную работу в production-среде.

---

## Файл: `/home/sonra44/QIKI_DTMP/services/q_core_agent/state/tests/test_types.py`

**Тип:** Модуль тестов Python (`pytest`)

**Назначение:**
Содержит unit-тесты для основных структур данных (`DTOs`), определенных в `types.py`. Цель — гарантировать, что эти объекты создаются корректно, являются неизменяемыми (`immutable`), и что вспомогательные функции для их создания и обновления работают предсказуемо.

**Ключевые сценарии тестирования:**
-   **Неизменяемость (`Immutability`)**: Самый важный тест в этом файле. С помощью `pytest.raises(FrozenInstanceError)` проверяется, что после создания объекта `FsmSnapshotDTO` или `TransitionDTO` его атрибуты нельзя изменить. Это ключевое архитектурное решение для предсказуемого управления состоянием.
-   **Корректность создания**: Тесты проверяют, что объекты создаются с правильными значениями по умолчанию, а также с переданными параметрами.
-   **Тестирование `next_snapshot()`**: Это ключевая функция для изменения состояния. Тесты проверяют, что:
    -   Версия корректно увеличивается только при реальном изменении состояния.
    -   Версия НЕ меняется, если состояние не изменилось.
    -   История переходов (`history`) правильно пополняется.
    -   Важные метаданные (например, `fsm_instance_id`) сохраняются между состояниями.
-   **Тестирование граничных случаев**: Проверяется работа с пустыми строками, `None`, большими коллекциями и Unicode-символами.

**Архитектурная значимость:**
-   Эти тесты — фундамент всей системы состояний. Они обеспечивают выполнение главного принципа — **неизменяемости (immutability)**. Это предотвращает огромное количество потенциальных ошибок, когда разные части программы могли бы случайно изменить один и тот же объект состояния.
-   Тесты для `initial_snapshot()` и `next_snapshot()` подтверждают использование паттерна «Фабрика» для создания состояний, что делает API для управления состоянием более безопасным и предсказуемым.
-   Вместе с другими файлами тестов (`test_store`, `test_conv`, `test_integration`) этот файл демонстрирует многоуровневую стратегию тестирования: от базовых типов данных до их хранения, сериализации и совместной работы.

---

## Файл: `/home/sonra44/QIKI_DTMP/services/q_core_agent/state/tests/__init__.py`

**Тип:** Инициализатор пакета Python

**Назначение:**
Этот файл маркирует директорию `tests` как пакет Python, что позволяет импортировать из нее модули. Комментарии в файле также служат кратким оглавлением, описывая назначение каждого тестового модуля в пакете.

**Архитектурная значимость:**
-   Стандартная практика в Python для организации кода в виде пакетов.
-   Помогает в навигации и понимании структуры тестового набора.

---

## Файл: `/home/sonra44/QIKI_DTMP/services/q_core_agent/core/tick_orchestrator.py`

**Тип:** Модуль Python

**Назначение:**
Определяет класс `TickOrchestrator`, который управляет основным циклом («тиком») работы агента. Он выступает в роли «дирижера», который обеспечивает последовательное выполнение всех фаз обработки данных, а также добавляет логирование и обработку ошибок.

**Ключевые функции:**
-   **Два режима работы**: Оркестратор может работать в двух режимах в зависимости от переменной окружения `QIKI_USE_STATESTORE`:
    1.  **Асинхронный (`run_tick_async`)**: Основной режим, который использует `AsyncStateStore` для управления состоянием. Это позволяет отделить логику конечного автомата от поставщика данных.
    2.  **Синхронный (`run_tick`)**: Устаревший режим для обратной совместимости, где состояние получается напрямую от поставщика данных.
-   **Структурированное логирование**: В конце каждого «тика» записывается подробная информация, включая длительность каждой фазы (обновление контекста, обработка BIOS, FSM и т.д.), что крайне полезно для отладки и профилирования производительности.
-   **Обработка ошибок**: Весь цикл обернут в `try...except`, что позволяет перехватывать сбои на любом этапе, переводить агент в безопасный режим (`_switch_to_safe_mode`) и избегать полного падения сервиса.

**Архитектурная значимость:**
-   Четко разделяет логику агента (ЧТО делать) от управления жизненным циклом (КОГДА и в КАКОМ ПОРЯДКЕ это делать).
-   Наличие двух режимов работы является ярким признаком эволюции архитектуры — перехода от простой модели состояний к более надежной, персистентной модели на основе `StateStore`.
-   Детальное логирование производительности указывает на зрелый подход к разработке и ориентацию на стабильную работу в production-среде.

---

## Файл: `/home/sonra44/QIKI_DTMP/services/q_core_agent/state/tests/test_types.py`

**Тип:** Модуль тестов Python (`pytest`)

**Назначение:**
Содержит unit-тесты для основных структур данных (`DTOs`), определенных в `types.py`. Цель — гарантировать, что эти объекты создаются корректно, являются неизменяемыми (`immutable`), и что вспомогательные функции для их создания и обновления работают предсказуемо.

**Ключевые сценарии тестирования:**
-   **Неизменяемость (`Immutability`)**: Самый важный тест в этом файле. С помощью `pytest.raises(FrozenInstanceError)` проверяется, что после создания объекта `FsmSnapshotDTO` или `TransitionDTO` его атрибуты нельзя изменить. Это ключевое архитектурное решение для предсказуемого управления состоянием.
-   **Корректность создания**: Тесты проверяют, что объекты создаются с правильными значениями по умолчанию, а также с переданными параметрами.
-   **Тестирование `next_snapshot()`**: Это ключевая функция для изменения состояния. Тесты проверяют, что:
    -   Версия корректно увеличивается только при реальном изменении состояния.
    -   Версия НЕ меняется, если состояние не изменилось.
    -   История переходов (`history`) правильно пополняется.
    -   Важные метаданные (например, `fsm_instance_id`) сохраняются между состояниями.
-   **Тестирование граничных случаев**: Проверяется работа с пустыми строками, `None`, большими коллекциями и Unicode-символами.

**Архитектурная значимость:**
-   Эти тесты — фундамент всей системы состояний. Они обеспечивают выполнение главного принципа — **неизменяемости (immutability)**. Это предотвращает огромное количество потенциальных ошибок, когда разные части программы могли бы случайно изменить один и тот же объект состояния.
-   Тесты для `initial_snapshot()` и `next_snapshot()` подтверждают использование паттерна «Фабрика» для создания состояний, что делает API для управления состоянием более безопасным и предсказуемым.
-   Вместе с другими файлами тестов (`test_store`, `test_conv`, `test_integration`) этот файл демонстрирует многоуровневую стратегию тестирования: от базовых типов данных до их хранения, сериализации и совместной работы.

---

## Файл: `/home/sonra44/QIKI_DTMP/services/q_core_agent/state/tests/__init__.py`

**Тип:** Инициализатор пакета Python

**Назначение:**
Этот файл маркирует директорию `tests` как пакет Python, что позволяет импортировать из нее модули. Комментарии в файле также служат кратким оглавлением, описывая назначение каждого тестового модуля в пакете.

**Архитектурная значимость:**
-   Стандартная практика в Python для организации кода в виде пакетов.
-   Помогает в навигации и понимании структуры тестового набора.

---

## Файл: `/home/sonra44/QIKI_DTMP/services/q_core_agent/core/tick_orchestrator.py`

**Тип:** Модуль Python

**Назначение:**
Определяет класс `TickOrchestrator`, который управляет основным циклом («тиком») работы агента. Он выступает в роли «дирижера», который обеспечивает последовательное выполнение всех фаз обработки данных, а также добавляет логирование и обработку ошибок.

**Ключевые функции:**
-   **Два режима работы**: Оркестратор может работать в двух режимах в зависимости от переменной окружения `QIKI_USE_STATESTORE`:
    1.  **Асинхронный (`run_tick_async`)**: Основной режим, который использует `AsyncStateStore` для управления состоянием. Это позволяет отделить логику конечного автомата от поставщика данных.
    2.  **Синхронный (`run_tick`)**: Устаревший режим для обратной совместимости, где состояние получается напрямую от поставщика данных.
-   **Структурированное логирование**: В конце каждого «тика» записывается подробная информация, включая длительность каждой фазы (обновление контекста, обработка BIOS, FSM и т.д.), что крайне полезно для отладки и профилирования производительности.
-   **Обработка ошибок**: Весь цикл обернут в `try...except`, что позволяет перехватывать сбои на любом этапе, переводить агент в безопасный режим (`_switch_to_safe_mode`) и избегать полного падения сервиса.

**Архитектурная значимость:**
-   Четко разделяет логику агента (ЧТО делать) от управления жизненным циклом (КОГДА и в КАКОМ ПОРЯДКЕ это делать).
-   Наличие двух режимов работы является ярким признаком эволюции архитектуры — перехода от простой модели состояний к более надежной, персистентной модели на основе `StateStore`.
-   Детальное логирование производительности указывает на зрелый подход к разработке и ориентацию на стабильную работу в production-среде.

---

## Файл: `/home/sonra44/QIKI_DTMP/services/q_core_agent/state/tests/test_types.py`

**Тип:** Модуль тестов Python (`pytest`)

**Назначение:**
Содержит unit-тесты для основных структур данных (`DTOs`), определенных в `types.py`. Цель — гарантировать, что эти объекты создаются корректно, являются неизменяемыми (`immutable`), и что вспомогательные функции для их создания и обновления работают предсказуемо.

**Ключевые сценарии тестирования:**
-   **Неизменяемость (`Immutability`)**: Самый важный тест в этом файле. С помощью `pytest.raises(FrozenInstanceError)` проверяется, что после создания объекта `FsmSnapshotDTO` или `TransitionDTO` его атрибуты нельзя изменить. Это ключевое архитектурное решение для предсказуемого управления состоянием.
-   **Корректность создания**: Тесты проверяют, что объекты создаются с правильными значениями по умолчанию, а также с переданными параметрами.
-   **Тестирование `next_snapshot()`**: Это ключевая функция для изменения состояния. Тесты проверяют, что:
    -   Версия корректно увеличивается только при реальном изменении состояния.
    -   Версия НЕ меняется, если состояние не изменилось.
    -   История переходов (`history`) правильно пополняется.
    -   Важные метаданные (например, `fsm_instance_id`) сохраняются между состояниями.
-   **Тестирование граничных случаев**: Проверяется работа с пустыми строками, `None`, большими коллекциями и Unicode-символами.

**Архитектурная значимость:**
-   Эти тесты — фундамент всей системы состояний. Они обеспечивают выполнение главного принципа — **неизменяемости (immutability)**. Это предотвращает огромное количество потенциальных ошибок, когда разные части программы могли бы случайно изменить один и тот же объект состояния.
-   Тесты для `initial_snapshot()` и `next_snapshot()` подтверждают использование паттерна «Фабрика» для создания состояний, что делает API для управления состоянием более безопасным и предсказуемым.
-   Вместе с другими файлами тестов (`test_store`, `test_conv`, `test_integration`) этот файл демонстрирует многоуровневую стратегию тестирования: от базовых типов данных до их хранения, сериализации и совместной работы.

---

## Файл: `/home/sonra44/QIKI_DTMP/services/q_core_agent/state/tests/test_store.py`

**Тип:** Модуль тестов Python (`pytest`)

**Назначение:**
Содержит unit-тесты для самого класса `AsyncStateStore`. Цель — проверить, что ключевые функции хранилища (запись, чтение, версионирование, система подписок) работают корректно и надежно в изоляции от остальной системы.

**Ключевые сценарии тестирования:**
-   **Базовые операции**: Проверяется корректность `set()` и `get()`, а также поведение при работе с пустым хранилищем.
-   **Версионирование**: Тестируется автоматическое увеличение версии при каждой записи (`set`) и принудительная проверка версии (`enforce_version=True`) для предотвращения гонок данных.
-   **Система подписок (Pub/Sub)**:
    -   Проверяется, что новый подписчик сразу получает текущее состояние.
    -   Гарантируется, что все подписчики получают обновления при изменении состояния.
    -   Тестируется отписка (`unsubscribe`) и автоматическая очистка «мертвых» подписчиков.
-   **Конкурентный доступ**: Очень важная часть тестов, которая имитирует одновременный доступ к хранилищу из разных частей программы (`asyncio.gather`). Проверяется, что блокировки (`lock`) работают корректно и не приводят к повреждению данных.
-   **Метрики и Health Check**: Тестируется, что внутренние метрики (счетчики операций, конфликтов версий) и проверка «здоровья» (`health_check`) работают правильно.

**Архитектурная значимость:**
-   Этот файл доказывает надежность `AsyncStateStore` — центрального компонента всей архитектуры управления состоянием.
-   Тщательное тестирование конкурентного доступа и механизма подписок абсолютно необходимо для создания стабильного, событийно-ориентированного приложения.
-   Тесты подтверждают, что хранилище спроектировано с учетом предотвращения классических проблем управления состоянием, таких как потерянные обновления и гонки данных.
