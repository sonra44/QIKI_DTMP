# NEW_QIKI_PLATFORM_DESIGN.md: QIKI Digital Twin Microservices Platform (QIKI_DTMP)

## 1. Введение
Этот документ описывает стратегический план разработки "QIKI Digital Twin Microservices Platform" (QIKI_DTMP). Целью является создание надежной, масштабируемой и безопасной системы, избегая архитектурных несоответствий, гонок состояний, дублирования кода, заглушек и сломанных тестов, которые были выявлены в предыдущих проектах.

## 2. Общая Архитектура
Система будет разделена на три специализированных микросервиса с четкими границами ответственности и сетевыми интерфейсами:
*   **Q-Sim Service:** Отвечает за симуляцию физического мира, сенсоров и окружения.
*   **Q-Core Agent:** Центральный мозг бота, управляющий FSM, принятием решений и исполнительными механизмами.
*   **Q-Operator Console:** Пользовательский интерфейс для мониторинга, управления и диагностики системы (только CLI/TUI, без веб-интерфейсов).

## 3. Принципы Проектирования ("Суперплан")

### 3.1. Основные Принципы
*   **Детализация до атомарного уровня:** Каждый компонент, функция, API и структура данных будут описаны с максимальной детализацией *до* начала кодирования.
*   **Многоуровневая Верификация:**
    *   **Документация:** Каждый дизайн-документ будет проходить твой анализ и утверждение.
    *   **Автоматизация:** Максимальное использование автоматизированных тестов (юнит, интеграционные, системные) и инструментов статического анализа (линтеры, тайп-чекеры).
    *   **Проактивный Анализ:** Я буду постоянно анализировать предлагаемые решения на предмет потенциальных проблем (гонки данных, узкие места, несовместимости) и предлагать альтернативы.
*   **Итеративная Разработка с Четкой "Definition of Done":** Каждый небольшой шаг будет иметь четкие критерии завершения, включая пройденные тесты и обновленную документацию.
*   **Централизованная База Знаний:** Вся проектная документация будет храниться в структурированном виде, легко доступном для поиска и обновления.
*   **Уроки Прошлого:** Все выявленные проблемы из `QIKIMAIN-main`, `qiki_bot`, `qiki_hardware`, `qiki_sim_project`, `qiki_termux` будут учтены и активно предотвращены.

### 3.2. Критические Улучшения (Режим Сверхосторожности для Инструментов)

1.  **Автоматизированный Template-Генератор для design.md и ADR (`qiki-docgen`):**
    *   **Назначение:** Ускорение создания консистентной документации.
    *   **Решение:** Разработка утилиты `qiki-docgen` (Python/Bash скрипт), генерирующей шаблоны `.md` с необходимой структурой, TODO-блоками, шаблонами диаграмм (PlantUML/Mermaid) и заготовками JSON-схем. Будет иметь интерактивный режим.

2.  **Механизм строгой Синхронизации FSM через EventStore + Lock-layer:**
    *   **Назначение:** Предотвращение гонок состояний в FSM.
    *   **Решение:** Реализация механизма строгой синхронизации FSM, используя локальные soft-lock файлы (например, с checksum валидацией) или другие подходящие механизмы для предотвращения одновременных state transitions. FSM Design будет храниться как JSON и визуализироваться через PlantUML/Mermaid.

3.  **Тесты как Папка, а не Комментарии (`.test.md` и генерация `pytest`-совместимого кода):**
    *   **Назначение:** Автоматизация тестирования на основе документации.
    *   **Решение:** Разработка механизма, парсящего `.test.md` файлы и генерирующего `pytest`-совместимый код для автоматизированных тестов.

4.  **"QIKI Index" – Автоиндексация Документов (`docs/INDEX.md`):**
    *   **Назначение:** Улучшение навигации по документации.
    *   **Решение:** Функционал в `qiki-docgen` для автоматического обновления `docs/INDEX.MD` со ссылками на все `design.md`, `test.md` и ADR.

5.  **Фреймворк для JSON-схем + генератор типов:**
    *   **Назначение:** Обеспечение строгой типизации и валидации данных.
    *   **Решение:** Использование `datamodel-code-generator` (или аналога) для генерации Python `dataclass` (или других типов) из JSON-схем.

6.  **Авто-Diagram генератор (PlantUML / Mermaid):**
    *   **Назначение:** Автоматическая генерация и актуализация диаграмм.
    *   **Решение:** Интеграция `mmdc` (Mermaid CLI) или PlantUML; исходники диаграмм (`.puml` / `.mmd`) будут храниться рядом с `.md` файлами.

7.  **Shell-команда для быстрой генерации boilerplate:**
    *   **Назначение:** Ускорение рутинных операций.
    *   **Решение:** Подготовка команд для добавления алиасов в `.bashrc` или `.zshrc` (например, `newcomp`, `newadr`, `runtest`).

8.  **Стратегия rollback для проблемных микросервисов:**
    *   **Назначение:** Механизм восстановления после сбоев.
    *   **Решение:** Заложение механизмов отката (например, через сохранение событий или версионирование состояния) и фиксация критичных действий в `action.log` при проектировании каждого микросервиса.

9.  **Жёсткое соблюдение структуры DONE через CI-файл (`.done-check.yml`):**
    *   **Назначение:** Формализация и автоматизация процесса приемки.
    *   **Решение:** Создание файла `.done-check.yml` и разработка скрипта для его парсинга и верификации "Definition of Done" на каждом этапе. Будет иметь pre-commit hook.

10. **"Антипаттерны" в дизайн-документах:**
    *   **Назначение:** Предотвращение повторения прошлых ошибок.
    *   **Решение:** Добавление раздела "Не делай так (Past Failures)" в дизайн-документы, основанного на анализе ошибок `qiki_main` и других прошлых проектов.

11. **Проверка API по контрактам:**
    *   **Назначение:** Обеспечение стабильности взаимодействия между компонентами.
    *   **Решение:** Использование Swagger/OpenAPI (или простейшего `.json`) для описания API и валидация по контрактам.

12. **Подключение real-world physics lib в проектировании:**
    *   **Назначение:** Обеспечение реалистичной симуляции.
    *   **Решение:** Использование библиотек, таких как Box2D или Bullet Physics, для физической симуляции.

13. **Слои мира = модули:**
    *   **Назначение:** Упрощение разработки, тестирования и поддержки симуляции.
    *   **Решение:** Разделение мира на модульные слои (terrain, obstacles, dynamic-objects) с отдельными интерфейсами.

14. **Логгер событий мира для отладки:**
    *   **Назначение:** Детальная отладка симуляции.
    *   **Решение:** Использование `loguru` или структурированного логгера для записи событий сенсоров и мира.

15. **"Step debugger" режим симуляции:**
    *   **Назначение:** Пошаговая отладка симуляции.
    *   **Решение:** Реализация функции `next_tick()` для ручного шага симуляции.

16. **Пульт = CLI + TUI (через textual):**
    *   **Назначение:** Удобный и функциональный пользовательский интерфейс без веб-интерфейсов.
    *   **Решение:** Использование библиотеки `textual` для создания текстового пользовательского интерфейса.

17. **Тест-кейсы = скрипты CLI (как сценарии):**
    *   **Назначение:** Автоматизация тестирования CLI-интерфейса.
    *   **Решение:** Описание тест-кейсов в YAML-файлах (например, `test/cli_scenarios/`) для автоматического запуска.

18. **Сценарии тестов интеграции как YAML-файлы:**
    *   **Назначение:** Повышение читаемости и поддерживаемости интеграционных тестов.
    *   **Решение:** Описание сценариев в YAML-файлах (например, `qiki_scenario_tests/`) с автозапуском через `pytest + yaml loader`.

19. **Сетевой профайлер на этапе интеграции:**
    *   **Назначение:** Выявление узких мест в производительности межкомпонентного взаимодействия.
    *   **Решение:** Логирование и анализ всех операций чтения/записи JSON-файлов и парсинга/сериализации JSON.

20. **Автогенерация `README.md` из `design.md` + `user_guide.md`:**
    *   **Назначение:** Обеспечение актуальности и консистентности основной документации.
    *   **Решение:** Использование `qiki-docgen` или Pandoc для автоматической генерации `README.md`.

21. **"Post Mortem Guide":**
    *   **Назначение:** Быстрое реагирование на инциденты.
    *   **Решение:** Создание документации по устранению неполадок и восстановлению системы.

### 3.3. Версионирование

*   Все внешние API → semver (`/v1/fsm/status`).
*   JSON-схемы всех компонентов содержат поле `schema_version`.
*   При изменении схемы: создается новая `fsm_v2.schema.json`.

### 3.4. Контроль внешних зависимостей

*   Все зависимости (Python, bash, system-level) фиксируются в `tools/dependencies.lock`.
*   Перед использованием — утверждение.
*   Только: `requests`, `pydantic`, `loguru`, `pytest`, `mypy`, `rich`, `textual` и строго ограниченные lib для симуляции.

### 3.5. Контроль Совместимости

*   Каждое API содержит `X-QIKI-Version` заголовок.
*   Несовпадение версий → лог, но не сбой.
*   Совместимость фиксируется в `compatibility_matrix.md`.

### 3.6. Пример compatibility_matrix.md

| Q-Core Agent | Q-Sim Service | Q-Operator Console | Совместимость |
|--------------|---------------|--------------------|----------------|
| v1.0.0       | v1.0.0        | v1.0.0             | ✅ OK          |
| v1.0.1       | v1.0.0        | v1.0.0             | ⚠️ Только CLI  |

Файл формируется вручную после интеграционных тестов.

## 4. Детализация Микросервисов

### 4.1. Q-Sim Service
*   Назначение: Симуляция физического мира, сенсоров, окружения.
*   Ключевые компоненты:
    *   Модуль физической симуляции (с использованием real-world physics lib)
    *   Модуль симуляции сенсоров (с логгером событий мира)
    *   Интерфейс для взаимодействия с Q-Core Agent
    *   Модульные слои мира (terrain, obstacles, dynamic-objects)
*   Технологии: (будут предложены и обоснованы в детальных дизайн-документах)

### 4.2. Q-Core Agent
*   Назначение: Центральный мозг бота, FSM, принятие решений, управление исполнительными механизмами.
*   Ключевые компоненты:
    *   Finite State Machine (FSM) с EventStore и Lock-layer
    *   Rule Engine
    *   Модуль управления исполнительными механизмами
    *   Интерфейс для взаимодействия с Q-Sim Service и Q-Operator Console
    *   Поддержка "degraded mode":
        *   Если Q-Sim offline — Agent работает в dummy-сенсор режиме.
        *   Если Q-Operator недоступен — Agent сохраняет команды в очередь.
*   Технологии: (будут предложены и обоснованы в детальных дизайн-документах)

### 4.2.1. FSM Integrity Checks

*   Каждое `fsm.json` → проверка:
    *   Все `from_state` → `to_state` существуют.
    *   Отсутствие dead-ends.
    *   Нет циклов без выхода, кроме `idle`.
*   Валидация через `scripts/validate_fsm.py`.

### 4.2.2. Q-Core Agent → Журнал действий (`action.log`)

*   Каждое критичное действие (FSM переход, команду actuator) → запись в `action.log`.
*   Формат: JSON Lines + UTC timestamp.
*   Пример: `{"ts": "...", "actor": "fsm", "action": "MOVE", "target": "servo1"}`.

### 4.3. Q-Operator Console
*   Назначение: Пользовательский интерфейс для мониторинга, управления и диагностики системы.
*   Ключевые компоненты:
    *   CLI-интерфейс (с использованием textual)
    *   Модули визуализации данных
    *   Интерфейс для взаимодействия с Q-Core Agent
*   Технологии: (будут предложены и обоснованы в детальных дизайн-документах)

## 5. Инструменты и Технологии
Предлагаемые языки программирования, фреймворки, базы данных, инструменты для контейнеризации, оркестрации, логирования, мониторинга будут детализированы в соответствующих дизайн-документах. Для инструментов разработки и документации допускается использование внешних зависимостей в "Режиме Сверхосторожности".

### qiki-docgen

CLI для генерации:
- design.md
- test.md
- adr.md
- fsm.json
- .puml /.mmd
Команды:
- `qiki-docgen new-component ...`
- `qiki-docgen update-index`
- `qiki-docgen test-from-md ...`
- `qiki-docgen build-readme` (для автогенерации `README.md`)

### 5.1. Минимальная CI-проверка (Локальная)

На push (или перед коммитом через pre-commit hook):
- Запуск `pytest`
- Проверка `.done-check.yml` (через `./scripts/check-done.py`)
- Проверка линтера и type-checker (ruff + mypy)
- Сравнение с автогенерированным `README.md`

❗ Использование: `tox`, `pre-commit`, `pytest`, `ruff`, `mypy`.

### 5.2. Версионирование Зависимостей

Все зависимости (Python/system):
- фиксируются через `requirements.lock` (pip-compile).
- контроль версий через `scripts/check-deps.py`.
- внешние инструменты (`qiki-docgen`, `mmdc`, `plantuml`) фиксируются в `tools/tools.lock`.

### 5.3. Автосборка Документации

- `README.md` = автоген из `design.md` + `user_guide.md`.
- Команда: `qiki-docgen build-readme`.
- CI step: генерируется и сравнивается с текущим.

## 6. Высокоуровневый План Реализации

### 6.1. Этап MVP (Минимально Жизнеспособный Прототип)

**Цель:** Проверка взаимодействия: FSM + 1 сенсор + CLI управление. Доказательство корректности архитектуры и каналов связи.

Состав:
- Q-Core Agent (только FSM с 2–3 состояниями)
- Q-Sim Service (один статичный объект + один сенсор)
- Q-Operator Console (CLI: start, status, stop)

## 7. Заключение
Новая архитектура и подход к разработке позволят создать надежную, масштабируемую и безопасную систему, основанную на уроках, извлеченных из анализа всех предыдущих итераций.