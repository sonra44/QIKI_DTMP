# Дизайн: Ядро Бота (bot_core)

## 1. Обзор
Этот документ определяет компонент `bot_core`, который представляет собой фундаментальное, низкоуровневое определение сущности бота в рамках микросервиса Q-Core Agent. Он служит основой, на которой строится вся логика более высокого уровня, включая FSM (Конечный Автомат).

Цель `bot_core`:
- Уникально идентифицировать экземпляр бота.
- Управлять его статической конфигурацией и свойствами (например, профиль оборудования, физические ограничения).
- Определять "сырые", неинтерпретированные точки взаимодействия для сенсоров (`SensorRawIn`) и исполнительных механизмов (`ActuatorRawOut`).

Этот компонент намеренно отделен от FSM, чтобы обеспечить четкое различие между внутренними свойствами бота и его поведенческим состоянием.

### 1.1. Идентификация Бота
Уникальный ID бота критически важен для сценариев с несколькими агентами и для логирования.
- **Генерация:** ID генерируется один раз при самом первом запуске агента.
- **Сохранение:** ID хранится в отдельном, постоянном файле (например, `.qiki_bot.id`) вне основной конфигурации, чтобы бот сохранял свою идентичность даже при изменении конфигурации.
- **Формат:** `QIKI-{ГГГГММДД}-{8_символов_хэша}` (например, `QIKI-20250721-a1b2c3d4`).

## 2. Функциональные Требования
- **Инициализация:** Компонент должен загружать свою конфигурацию из `bot_config.json` при старте.
- **Идентификация:** Должен предоставлять уникальный ID бота другим компонентам.
- **Доступ к Свойствам:** Должен предоставлять доступ к статическим свойствам (например, `max_speed`).
- **Потоки Данных:** Должен служить точкой входа для сырых данных от сенсоров и точкой выхода для сырых команд к актуаторам.

## 3. Архитектура и Дизайн
`bot_core` — это простой контейнер данных и слой-интерфейс. Он не содержит сложной логики. Его основная роль — хранить статическую конфигурацию бота и обеспечивать четкую границу между высокоуровневой логикой `Q-Core Agent` (например, FSM) и низкоуровневым `Q-Sim Service`.

Он также поддерживает **Буфер Информации Времени Выполнения (Runtime Info Buffer)** — read-only снимок последних известных значений от сенсоров и команд, отправленных актуаторам. Это критически важно для отладки и анализа состояния без опроса FSM.

```mermaid
graph TD
    subgraph Q-Core Agent (Агент)
        FSM(Конечный Автомат)
        RuleEngine(Движок Правил)
        Monitor(Инструменты Мониторинга)
    end

    subgraph Q-Sim Service (Симулятор)
        SensorSim(Симуляция Сенсоров)
        ActuatorSim(Симуляция Актуаторов)
    end

    Config[bot_config.json] --> CoreBot(Ядро Бота: bot_core)
    RuntimeBuffer["Буфер Runtime Информации (Внутренний)"] --.-> CoreBot

    CoreBot -- читает --> Config
    FSM -- использует --> CoreBot
    RuleEngine -- использует --> CoreBot
    Monitor -- читает --> RuntimeBuffer

    SensorSim -- "Сырой ввод сенсора" --> CoreBot
    CoreBot -- "Сырой вывод актуатора" --> ActuatorSim
```

## 4. Спецификация API
Компонент `bot_core` не предоставляет внешнего сетевого API. Он предоставляет программный API (Python-класс) для использования другими компонентами внутри микросервиса `Q-Core Agent`.

### Конфигурация и Свойства
- `get_id() -> str`: Возвращает уникальный ID бота.
- `get_property(property_name: str) -> Any`: Получает статическое свойство из загруженной конфигурации.

### Данные Сенсоров (Асинхронная Push/Pull Модель)
- `register_sensor_callback(callback: Callable[[SensorRawIn], None])`: Регистрирует callback-функцию, которая будет вызываться с новыми данными сенсора по мере их поступления (push-модель).
- `get_latest_sensor_value(sensor_id: str) -> Optional[SensorRawIn]`: Получает самое последнее значение для конкретного сенсора (pull-модель).
- `get_sensor_history(sensor_id: str, n: int = 10) -> List[SensorRawIn]`: Получает последние `n` значений для конкретного сенсора.

### Команды Актуаторам
- `send_actuator_command(command: ActuatorRawOut)`: Отправляет сырую команду на исполнительный механизм.

### Буфер Runtime Информации (Только для чтения)
- `@property current_sensor_snapshot() -> Dict[str, Any]`: Возвращает словарь последних известных значений для всех сенсоров.
- `@property last_actuator_commands() -> Dict[str, Any]`: Возвращает словарь последних команд, отправленных всем актуаторам.

## 5. Модели Данных
Компонент `bot_core` оперирует тремя основными моделями данных. Формальные JSON-схемы будут созданы в директории `/schemas`.

**1. Конфигурация Бота (`bot_config.json`):**
```json
{
  "schema_version": "1.0",
  "bot_id": "QIKI-20250721-a1b2c3",
  "bot_type": "explorer_v1",
  "mode": "full", // или "minimal"
  "hardware_profile": {
    "max_speed_mps": 2.5,
    "power_capacity_wh": 1000,
    "actuators": [
      {"id": "motor_left", "type": "wheel_motor"},
      {"id": "motor_right", "type": "wheel_motor"}
    ],
    "sensors": [
      {"id": "lidar_front", "type": "lidar"},
      {"id": "imu_main", "type": "imu"}
    ]
  }
}
```
*В режиме `minimal` секция `hardware_profile` может быть опущена. В этом режиме методы сенсоров/актуаторов неактивны, но не вызывают ошибок, что облегчает юнит-тестирование логики верхнего уровня.*

**2. Сырые Входные Данные Сенсора (`SensorRawIn`):**
```json
{
  "timestamp_utc": "2025-07-21T18:30:00Z",
  "sensor_id": "lidar_front",
  "value": 10.5,
  "unit": "meters"
}
```

**3. Сырые Выходные Данные Актуатора (`ActuatorRawOut`):**
```json
{
  "actuator_id": "motor_left",
  "command": "set_velocity_percent",
  "value": 50
}
```

## 6. Анти-паттерны (Ошибки Прошлого)
Основываясь на анализе проектов в `_ARCHIVE`, следует строго избегать следующих анти-паттернов:

- **Смешивание Состояния и Конфигурации:** В `qiki_bot` телеметрия, состояние (FSM) и статическая конфигурация часто смешивались в одних файлах. `bot_core` должен работать только со статическими свойствами.
- **Неявные Контракты Данных:** Форматы сырых данных не были формально определены, что приводило к несоответствиям. `bot_core` должен полагаться на формальные схемы.
- **Отсутствие Постоянного ID:** Не было четкого механизма генерации ID, что усложняло мультиагентные сценарии.
- **Прямой Доступ к Оборудованию:** Модули часто обращались к файлам/оборудованию в обход абстракций. `bot_core` должен быть единственным интерфейсом для сырого ввода-вывода.
- **Монолитные Геттеры:** Функция `get_bot_status()` в `qiki_hardware` возвращала сотни полей, создавая жесткую связь. API `bot_core` должно быть атомарным и гранулярным.
- **Встроенные Конвертации Единиц:** В `qiki_termux` сенсоры передавали данные в нестандартных единицах (см, PWM). Все данные в `SensorRawIn` и `ActuatorRawOut` должны использовать стандартные единицы СИ, а конвертация должна производиться в адаптерах.
- **Небезопасные Откаты (Fallbacks):** `bot_core` должен аварийно завершать работу, если `bot_config.json` отсутствует или невалиден. Он не должен откатываться к "безопасной" конфигурации по умолчанию, так как это скрывает критические ошибки развертывания.

## 7. Открытые Вопросы
1.  **"Горячая" Перезагрузка Конфигурации:** Должен ли `bot_core` поддерживать перезагрузку своей конфигурации из `bot_config.json` во время выполнения, или требуется перезапуск? Для MVP предполагается перезапуск.
2.  **Место Валидации Схем:** Где должна происходить валидация схем `SensorRawIn` и `ActuatorRawOut`? В самом `bot_core` или на границе `Q-Sim Service` / драйвера реального оборудования?
