# Дизайн: Нейро-Гибридное Ядро (Q-Mind)

## 1. Обзор
Q-Mind — это центральный компонент принятия решений в `Q-Core Agent`. Он реализует гибридную модель, сочетающую детерминированный движок правил для обеспечения безопасности и рефлексов, и адаптивный нейронный движок для сложной аналитики и оптимизации. Финальное решение принимается модулем "Арбитр".

```mermaid
graph TD
    subgraph BIOS
        SENSORS["Поток Данных от Сенсоров"]
    end

    subgraph Q-Mind
        RULE[Rule Engine<br>“Рефлекторный Мозг”] 
        NEURAL[Neural Engine<br>“Адаптивный Мозг”]
        ARBITER[Arbiter<br>“Исполнительная кора”]
    end

    subgraph FSM Layer
        FSM[Клиент FSM]
    end

    SENSORS --> RULE
    SENSORS --> NEURAL

    RULE -- "Приоритетное Предложение" --> ARBITER
    NEURAL -- "Опциональное Предложение" --> ARBITER

    ARBITER -- "Финальная Команда" --> FSM
    ARBITER -- "Обратная связь (отклонено)" -.-> NEURAL
```

## 2. Компоненты

### 2.1. Rule Engine (Движок Правил)
- **Назначение:** Обеспечение безопасности, выполнение рефлекторных действий.
- **Логика:** Работает на основе жестко заданных, нерушимых правил. Включает модуль **"Safe Zone Enforcement"** для контроля за критическими параметрами (положение, ориентация).
- **Выход:** Генерирует `Proposal Object` с приоритетом `critical` или `high`.

### 2.2. Neural Engine (Нейронный Движок)
- **Назначение:** Анализ сложных паттернов, предсказание, оптимизация.
- **Логика:** Основан на одной или нескольких нейросетевых моделях. Не управляет ботом напрямую, а генерирует "советы".
- **Обратная связь:** Получает от Арбитра информацию, если его предложение было отклонено (и по какой причине), что может быть использовано для дообучения.
- **Выход:** Генерирует `Proposal Object` с приоритетом `normal` или `low` и уровнем уверенности (`confidence`).

### 2.3. Arbiter (Арбитр)
- **Назначение:** Принятие финального решения на основе предложений от движков.
- **Логика:**
    1. Всегда обрабатывает предложения от `Rule Engine` первыми.
    2. Если есть критическое предложение, оно немедленно отправляется в FSM, а предложение от `Neural Engine` отклоняется.
    3. Если критических предложений нет, анализирует предложение от `Neural Engine`.
    4. Отправляет финальную команду клиенту FSM.

## 3. Модель Данных: Proposal Object
Унифицированный объект для предложений от обоих движков. Его формальная схема будет описана в `/schemas/qmind_proposal.schema.json`.

```json
{
  "source": "neural_engine",
  "timestamp_utc": "2025-07-21T22:30:00Z",
  "priority": "normal", // critical | high | normal | low
  "command": "MOVE_TO_VECTOR",
  "payload": {"x": 10, "y": 25, "speed": 0.8},
  "confidence": 0.88,
  "rationale": "Optimal path to avoid high radiation zone.",
  "dependencies": ["motor_left", "motor_right", "imu_main"]
}
```

## 4. Контракты и API
- **Горячая замена:** Каждый из трех компонентов (Rule, Neural, Arbiter) должен быть реализован как отдельный, инкапсулированный модуль, который можно перезагрузить ("hot-reload") без остановки всего `Q-Mind`.
- **API Арбитра:** `Arbiter.submit_proposal(proposal: ProposalObject)`.

## 5. Анти-паттерны
- **Прямой доступ к FSM:** Ни `Rule Engine`, ни `Neural Engine` не должны иметь прямого доступа к клиенту FSM. Все взаимодействие — только через `Arbiter`.
- **Неструктурированные предложения:** Обмен между компонентами должен происходить только через строго валидируемый `Proposal Object`.

## 6. Открытые Вопросы
1.  Какую конкретную архитектуру нейронной сети использовать для `Neural Engine` в MVP?
2.  Как будет реализован механизм "горячей замены" на уровне кода?
3.  Нужен ли механизм онлайн-дообучения для `Neural Engine` на основе обратной связи от Арбитра, или дообучение будет происходить только офлайн?