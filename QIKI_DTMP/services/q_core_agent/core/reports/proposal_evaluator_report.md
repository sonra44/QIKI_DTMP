# proposal_evaluator.py — обзор

## Вход и цель
- [Факт] анализ модуля `proposal_evaluator.py` с задачами и рисками

## Сбор контекста
- [Факт] реализует `ProposalEvaluator` по интерфейсу `IProposalEvaluator`
- [Факт] использует сортировку по типу и приоритету
- [Гипотеза] расширяемость под дополнительные критерии оценки

## Локализация артефакта
- [Факт] путь: `services/q_core_agent/core/proposal_evaluator.py`
- [Гипотеза] вызывается `NeuralEngine` и другими источниками предложений

## Фактический разбор
- [Факт] конструктор принимает `proposal_confidence_threshold`
- [Факт] `evaluate_proposals` отбрасывает низкую уверенность
- [Факт] выбор лучшего предложения происходит по типу, приоритету, уверенности
- [Гипотеза] не возвращает несколько предложений одного типа

## Роль в системе и связи
- [Факт] агрегирует и фильтрует предложения для дальнейшего выполнения
- [Гипотеза] служит центральной точкой принятия решений агента

## Несоответствия и риски
- [Факт] сравнение `ProposalType` через ordinal (Med)
- [Гипотеза] отсутствие тайм-стемпа или проверки источника (Low)

## Мини-патчи (safe-fix)
- [Патч] явно сопоставить приоритет типов через словарь вместо ordinal
- [Патч] логировать количество отклонённых предложений

## Рефактор-скетч
```python
TYPE_PRIORITY = {Proposal.ProposalType.SAFETY: 0,
                 Proposal.ProposalType.PLANNING: 1}
```

## Примеры использования
```python
evaluator = ProposalEvaluator({"proposal_confidence_threshold": 0.7})
accepted = evaluator.evaluate_proposals(proposals)
```

## Тест-хуки/чек-лист
- [Факт] unit-тест: сортировка по типу и приоритету
- [Гипотеза] интеграция: обработка пустого списка

## Вывод
- [Факт] модуль корректно фильтрует предложения, но зависит от ordinal значений типов
- [Патч] стоит внедрить явную таблицу приоритетов и расширенные логи

## Стиль и маркировка
- [Факт] — по исходнику
- [Гипотеза] — по косвенным признакам
- [Патч] — предложенные изменения
