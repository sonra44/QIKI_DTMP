# QIKI Digital Twin Microservices Platform (QIKI_DTMP) - Полное Руководство

**Версия Документа:** 2.0 (Полный анализ)  
**Дата Последней Верификации:** 2025-09-03

---

## 1. Философия и Назначение Проекта

**QIKI_DTMP** — это высокопроизводительная, модульная платформа для разработки, симуляции и запуска интеллектуальных агентов, спроектированная с фокусом на надежность и масштабируемость. Изначально задуманный как архитектурный макет и "цифровой двойник" для AI-агента, проект эволюционировал в сложную экосистему, готовую к реальным задачам.

### Ключевые Принципы ("Почему?"):

-   **Надежность превыше всего:** Проект является прямым ответом на предыдущие неудачные итерации, страдавшие от гонок состояний, неконсистентности данных и скрытых ошибок. Главный принцип — создание предсказуемой и стабильной системы.
-   **Document-First & Contract-Oriented:** Каждый компонент сначала описывается в детальных дизайн-документах, а взаимодействие между сервисами строго регламентируется через Protobuf-контракты. Это гарантирует, что все части системы "говорят на одном языке".
-   **Эволюционная Архитектура:** Система спроектирована для роста — от базового наземного робота (`Bot`) до сложного космического аппарата (`Ship`) и, в перспективе, до управления флотом.
-   **Проверяемость и Честность:** Встроенные механизмы (`ANTI_FRAUD_DOCUMENTATION_PROTOCOL.md`, `AI_DEVELOPER_PRINCIPLES.md`) требуют, чтобы каждое утверждение о готовности системы было подкреплено практическими тестами.

### Как это работает ("Как?"):

Система состоит из двух ключевых микросервисов:
1.  **`Q-Core Agent`**: "Мозг" агента. Работает в дискретном цикле ("тике"), на каждом шаге получая данные, обрабатывая их через конечный автомат (FSM) и принимая решения.
2.  **`Q-Sim Service`**: Симулятор физического мира. Генерирует данные сенсоров и исполняет команды, полученные от агента.

Взаимодействие между ними происходит через два независимых слоя коммуникации:
-   **gRPC:** Для прямых, синхронных запросов (например, "получить данные сенсора").
-   **NATS (через FastStream):** Для асинхронного, событийно-ориентированного обмена сообщениями в распределенной среде.

---

## 2. Архитектура и Ключевые Компоненты

### 2.1. Ядро Управления Состоянием (`services/q_core_agent/state/`)

Это сердце всей системы, спроектированное для предотвращения гонок данных и обеспечения консистентности.

-   **`AsyncStateStore` (`store.py`):** Потокобезопасное in-memory хранилище, являющееся **Единственным Источником Правды (Single Source of Truth)** для состояния агента.
    -   **Зачем:** Решает классические проблемы многопоточных систем.
    -   **Как:** Использует `asyncio.Lock` для защиты операций, версионирование для предотвращения записи устаревших данных и Pub/Sub механизм (`asyncio.Queue`) для уведомления подписчиков об изменениях.

-   **Неизменяемые DTO (`types.py`):** Объекты для передачи данных (`FsmSnapshotDTO`, `TransitionDTO`) спроектированы как **неизменяемые (`frozen=True`)**.
    -   **Зачем:** Гарантирует, что состояние не может быть случайно изменено в разных частях программы. Для обновления создается новый объект.
    -   **Как:** Используется стандартный декоратор `@dataclass(frozen=True)`.

-   **Конвертеры (`conv.py`):** Модуль-«переводчик» между внутренними DTO и внешним Protobuf-форматом.
    -   **Зачем:** Реализует паттерн **Anti-Corruption Layer**, защищая ядро системы от деталей формата передачи данных.
    -   **Как:** Содержит функции `dto_to_proto` и `proto_to_dto`, а также маппинги для `enum`-типов.

### 2.2. Логика Агента (`services/q_core_agent/core/`)

-   **`QCoreAgent` (`agent.py`):** Главный класс-оркестратор. Не содержит сложной логики, а лишь координирует работу других компонентов.
-   **`TickOrchestrator` (`tick_orchestrator.py`):** "Дирижер", управляющий жизненным циклом агента. Разделяет логику (ЧТО делать) от процесса (КОГДА и в КАКОМ ПОРЯДКЕ).
-   **`FSMHandler` (`fsm_handler.py`):** Хранитель логики конечного автомата. Единственное место, где определены правила переходов между состояниями (`BOOTING` -> `IDLE` -> `ACTIVE`). Является единственным **"писателем"** в `AsyncStateStore`.
-   **Движки Принятия Решений (`rule_engine.py`, `neural_engine.py`):**
    -   **`RuleEngine`:** Генерирует "предложения" (Proposals) на основе жестко заданных правил. **Текущая реализация:** Генерирует предложение только при ошибке BIOS.
    -   **`NeuralEngine`:** **Является заглушкой (placeholder).** Не содержит реальной ML-логики.
-   **`ProposalEvaluator` (`proposal_evaluator.py`):** Оценивает предложения от движков и выбирает лучшее на основе приоритета и уверенности.

### 2.3. Симулятор (`services/q_sim_service/`)

-   **`QSimService` (`main.py`):** Основной сервис симуляции.
-   **`WorldModel` (`core/world_model.py`):** Хранит состояние симулируемого объекта (позиция, скорость, заряд батареи).
-   **`grpc_server.py`:** Реализация gRPC сервера для взаимодействия с агентом.

### 2.4. Контракты Данных (`protos/`)

Это самая сильная и зрелая часть проекта. Контракты спроектированы с учетом будущих потребностей (космические операции, сложные миссии).
-   **`common_types.proto`:** Базовые типы (`UUID`, `Vector3`, `Unit`).
-   **`sensor_raw_in.proto`:** Универсальный формат для любых сенсорных данных.
-   **`actuator_raw_out.proto`:** Надежные команды с `retry_count`, `timeout_ms`.
-   **`proposal.proto`:** Сложная система предложений с графом зависимостей (`depends_on`, `conflicts_with`).

### 2.5. Альтернативная Реализация (`UP/`)

Директория `UP/` содержит альтернативную, более новую ветку разработки ядра системы.
-   **Основное отличие:** Использует **Pydantic** модели вместо Protobuf DTO.
-   **Содержит:** Собственные реализации `fsm_engine.py`, `dto_handler.py`, `store.py`.
-   **Статус:** Представляет собой перспективное направление для будущего рефакторинга, но на данный момент основной рабочей версией является та, что находится в `services/`.

---

## 3. Технологический Стек

-   **Язык:** Python 3.12
-   **Асинхронность:** `asyncio`
-   **Межсервисное взаимодействие:** `gRPC`, `FastStream` (поверх `NATS`)
-   **Валидация данных:** `Pydantic` (в `UP/` и `shared/`), `Protocol Buffers`
-   **Тестирование:** `pytest`, `pytest-asyncio`
-   **Контейнеризация:** `Docker`, `Docker Compose`
-   **Инструменты CI/CD:** `ruff` (линтинг), `shell-скрипты`

---

## 4. Как запустить и использовать

### Требования
-   Python 3.12+
-   Docker и Docker Compose
-   `protoc` (компилятор Protocol Buffers)

### Установка зависимостей
```bash
# Установка основных и faststream зависимостей
pip install -r requirements.txt && pip install -r requirements-faststream.txt
```

### Запуск через Docker (Рекомендуемый способ)
Этот способ автоматически поднимет все сервисы, включая NATS, в изолированной сети.

```bash
# Запустить все сервисы в фоновом режиме
docker-compose -f docker-compose.phase1.yml up --build -d

# Посмотреть логи агента
docker-compose -f docker-compose.phase1.yml logs -f qiki-dev
```

### Локальный запуск (для отладки)
Используйте `python3`.

1.  **Запустить gRPC сервер симулятора:**
    ```bash
    python3 services/q_sim_service/grpc_server.py
    ```

2.  **Запустить агента в отдельном терминале:**
    -   **В режиме gRPC (взаимодействие по сети):**
        ```bash
        python3 services/q_core_agent/main.py --grpc
        ```
    -   **В режиме с мок-данными (не требует симулятора):**
        ```bash
        python3 services/q_core_agent/main.py --mock
        ```
    -   **В Legacy режиме (прямой вызов в одном процессе):**
        ```bash
        python3 services/q_core_agent/main.py
        ```

### Запуск тестов
```bash
# Запустить все unit и integration тесты
python3 -m pytest

# Запустить полный hot-test для StateStore
./scripts/hot_test_statestore.sh
```

---

## 5. Структура Проекта

-   **/services**: Исходный код основных микросервисов (`q_core_agent`, `q_sim_service`, `faststream_bridge`).
-   **/UP**: Альтернативная реализация ядра системы на Pydantic.
-   **/protos**: `.proto` файлы, определяющие контракты данных для gRPC.
-   **/generated**: Автоматически сгенерированный Python-код из `.proto` файлов.
-   **/docs**: Проектная и архитектурная документация.
-   **/tests**: Комплексные тесты для проекта.
-   **/scripts**: Вспомогательные скрипты для тестирования и автоматизации.
-   **docker-compose.phase1.yml**: Файл для оркестрации сервисов с помощью Docker.
-   **requirements.txt**: Основные зависимости проекта.