# QIKI Digital Twin Microservices Platform (QIKI_DTMP)

## 1. Философия и Обзор Проекта

**QIKI_DTMP** — это высокопроизводительная платформа для разработки и запуска интеллектуальных агентов в симулированных средах. Проект представляет собой не просто набор сервисов, а целостную экосистему, построенную на принципах **модульности, гибкости и надежности**.

**Ключевая идея (Почему?):** Создать платформу, где сложная логика AI-агента (`QCoreAgent`) может быть разработана, протестирована и запущена в окружении, максимально приближенном к реальному (`QSimService`), но с полной изоляцией компонентов. Это достигается за счет строгого следования архитектурным принципам **SOLID** и использования интерфейсов для каждого компонента.

**Как это работает:** Агент (`QCoreAgent`) работает в цикле ("тике"), на каждом шаге получая данные от симулятора, обрабатывая их через конечный автомат (FSM) и принимая решения, которые отправляются обратно в симулятор в виде команд.

---

## 2. Детальный разбор компонентов

Архитектура системы состоит из нескольких ключевых, четко разделенных модулей.

### `QCoreAgent` — Мозг
-   **Что это?** Основной сервис, содержащий логику AI-агента. Он не выполняет прямых действий, а координирует работу других компонентов.
-   **Как работает?** Внутри каждого "тика" он последовательно опрашивает поставщика данных, вызывает обработчики состояний (BIOS, FSM), получает предложения от движков решений и выбирает лучшее для исполнения.

### `TickOrchestrator` — Дирижер
-   **Что это?** Класс, управляющий жизненным циклом агента.
-   **Почему он важен?** Он отделяет *логику* агента (что делать) от *процесса* (когда и в каком порядке). Это делает код чище и упрощает отладку.
-   **Как работает?** Запускает основной цикл, последовательно вызывает все необходимые фазы обработки, логирует время выполнения каждого этапа и обрабатывает ошибки, переводя агент в безопасный режим при сбоях.

### `FSMHandler` — Хранитель логики состояний
-   **Что это?** Обработчик конечного автомата (Finite State Machine).
-   **Почему он важен?** Это единственное место в системе, где определены правила переходов между состояниями агента (`BOOTING` -> `IDLE` -> `ACTIVE`). Централизация этой логики упрощает ее понимание и модификацию.
-   **Как работает?** Получает текущее состояние, анализирует его и внешние факторы (например, статус BIOS) и вычисляет следующее состояние. Результат записывается в `AsyncStateStore`.

### `AsyncStateStore` — Единственный источник правды
-   **Что это?** Потокобезопасное, асинхронное in-memory хранилище состояний.
-   **Почему это ядро архитектуры?** Оно решает классические проблемы многопоточных систем: гонки данных и потерянные обновления. Любой компонент может безопасно получить актуальное состояние агента.
-   **Как работает?**
    -   **Версионирование:** Каждое изменение состояния увеличивает версию. Это позволяет предотвратить запись устаревших данных.
    -   **Блокировки (`asyncio.Lock`):** Гарантируют, что только один компонент может изменять состояние в один момент времени.
    -   **Pub/Sub:** Компоненты могут подписаться на изменения и получать уведомления, как только состояние обновляется. Это основа событийно-ориентированной архитектуры.

### `DataProvider` — Органы чувств
-   **Что это?** Абстракция для получения данных из внешнего мира.
-   **Почему он важен?** Позволяет "отключить" агента от реального симулятора и подключить к тестовым данным без изменения кода самого агента.
-   **Как работает?** Существует несколько реализаций:
    -   `GrpcDataProvider`: Для взаимодействия с симулятором по сети через gRPC.
    -   `MockDataProvider`: Возвращает заранее заданные тестовые данные.
    -   `QSimDataProvider`: Для прямого взаимодействия с симулятором в одном процессе.

### `conv.py` — Переводчик (Anti-Corruption Layer)
-   **Что это?** Модуль, который преобразует данные из внутреннего формата (DTO) во внешний (Protobuf) и обратно.
-   **Почему он важен?** Он защищает ядро системы от деталей формата передачи данных. Если завтра потребуется перейти с Protobuf на JSON, изменения коснутся только этого модуля.
-   **Как работает?** Реализует паттерн "Адаптер", обеспечивая двустороннюю конвертацию без потерь, включая упаковку метаданных, отсутствующих в Protobuf-схеме.

---

## 3. Глубокое погружение в управление состоянием

**Проблема:** В сложных системах, где несколько частей программы могут одновременно читать и изменять общее состояние, легко допустить ошибку: одна часть перезаписывает изменения другой, или работает с устаревшими данными.

**Решение в QIKI_DTMP:**
1.  **Неизменяемые DTO (Data Transfer Objects):** Объекты состояния спроектированы как *неизменяемые* (`immutable`). После создания такого объекта его нельзя изменить. Чтобы поменять состояние, нужно создать *новый* объект на основе старого. Это гарантирует, что у разных частей программы не будет "своей" версии одного и того же состояния.
2.  **Централизованное хранилище (`AsyncStateStore`):** Вместо того чтобы передавать объект состояния по всей системе, компоненты получают его из `StateStore`. `FSMHandler` является единственным "писателем", а все остальные — "читателями" или "подписчиками". Это создает предсказуемый и однонаправленный поток данных.

---

## 4. Стратегия тестирования

Проект использует многоуровневый подход к тестированию, чтобы гарантировать надежность каждого аспекта системы:
-   **Unit-тесты (`test_types.py`, `test_store.py`):** Проверяют мельчайшие компоненты в изоляции, например, корректность создания DTO или работу версионирования в `StateStore`.
-   **Интеграционные тесты (`test_integration.py`):** Проверяют, как несколько компонентов работают вместе. Например, что при изменении состояния в `FSMHandler` подписчики `StateStore` получают правильное уведомление.
-   **Стресс-тесты (`test_stress.py`):** Проверяют систему в экстремальных условиях: тысячи одновременных запросов, нехватка памяти, высокая частота обновлений. Это доказывает готовность компонентов к production-нагрузкам.

---

## 5. Технологический стек

-   **Язык**: Python 3.12
-   **Асинхронность**: `asyncio`
-   **Межсервисное взаимодействие**:
    -   `gRPC` (для RPC)
    -   `FastStream` (поверх `NATS` для Pub/Sub)
-   **Валидация данных**: `Pydantic`
-   **Тестирование**: `pytest`, `pytest-asyncio`
-   **Контейнеризация**: `Docker`, `Docker Compose`
-   **Формат контрактов**: `Protocol Buffers`

---

## 6. Быстрый старт

### Требования

-   Python 3.12+
-   Docker и Docker Compose

### Установка зависимостей

```bash
# Установка основных и faststream зависимостей
pip install -r requirements.txt && pip install -r requirements-faststream.txt
```

### Запуск через Docker (Рекомендуемый способ)

Этот способ автоматически поднимет все сервисы, включая NATS, в изолированной сети.

```bash
# Запустить все сервисы в фоновом режиме
docker-compose -f docker-compose.phase1.yml up --build -d

# Посмотреть логи агента
docker-compose -f docker-compose.phase1.yml logs -f qiki-dev
```

### Локальный запуск

Для отладки можно запустить компоненты как отдельные локальные процессы.

1.  **Запустить симулятор (`QSimService`):**
    ```bash
    python3 UP/main.py
    ```

2.  **Запустить агента (`QCoreAgent`) в отдельном терминале:**
    -   **В режиме с мок-данными (не требует симулятора):**
        ```bash
        python3 services/q_core_agent/main.py --mock
        ```
    -   **В режиме gRPC (требует запущенного gRPC сервера симулятора):**
        ```bash
        python3 services/q_core_agent/main.py --grpc
        ```

### Запуск тестов

```bash
python3 -m pytest
```

---

## 7. Структура проекта

-   **/services**: Исходный код основных микросервисов (`q_core_agent`, `q_sim_service`).
-   **/protos**: Protobuf-файлы, определяющие контракты данных.
-   **/generated**: Автоматически сгенерированный Python-код из `.proto` файлов.
-   **/tests**: Комплексные тесты для проекта.
-   **/scripts**: Вспомогательные скрипты для тестирования и автоматизации.
-   **docker-compose.phase1.yml**: Файл для оркестрации сервисов с помощью Docker.
-   **Dockerfile.dev**: Docker-конфигурация для среды разработки.
-   **requirements.txt**: Основные зависимости проекта.
