# План разработки и улучшения QIKI Mission Control TUI

Этот план предназначен для агентного режима в Warp и описывает последовательные задачи по развитию терминальной консоли оператора. Каждая задача включает контекст, шаги и ожидаемый результат. Все задачи предполагают использование Python 3.12, соблюдение PEP 8, проверку Ruff, оценку Pylint не ниже 8/10, тестирование PyTest с покрытием ≥ 80 % и поддержку локализации (русский/английский).

## 1. Рефакторинг архитектуры и модульность

### Задача
Разбить монолитный файл `mission_control_tui.py` (≈700 строк) на отдельные модули, чтобы упорядочить код и упростить тестирование.

### Шаги
1. Создать в `src/qiki/ui` поддиректорию `widgets`.
2. Перенести классы виджетов в отдельные файлы:
   - `widgets/system_status.py` – класс `SystemStatusWidget` для панели состояния систем.
   - `widgets/navigation.py` – `NavigationWidget` для навигации и ориентации.
   - `widgets/radar.py` – `RadarWidget` для отображения контактов радаров (будет расширяться для реальных данных).
   - `widgets/propulsion.py` – `PropulsionWidget` для движительной установки.
   - `widgets/power.py` – `PowerWidget` для распределения энергии.
   - `widgets/event_log.py` – `EventLogWidget` для журнала событий.
   - `widgets/command_input.py` – `CommandInputWidget` для ввода команд и горячих клавиш.
3. Оставить в `mission_control_tui.py` только класс приложения и функцию `main()`; настроить импорты из пакета `widgets`.
4. Удалить изменение `sys.path` и заменить абсолютные импорты на относительные, оформив `qiki` как Python‑пакет (с правильными `__init__.py`).

### Ожидаемый результат
- Код станет модульным и легче поддерживаемым.
- Каждый виджет можно тестировать и дорабатывать независимо.

## 2. Реальная телеметрия и интеграция с JetStream/Event Store

### Задача
Вместо демонстрационных значений подключить консоль к реальным данным, поступающим через NATS JetStream и Event Store.

### Шаги
1. Создать `jetstream_client.py` с использованием библиотеки `nats.py` для подписки на топики: `system_status`, `navigation`, `propulsion`, `power`, `radar`.
2. Создать `event_store_client.py` или gRPC‑клиент для доступа к истории событий.
3. В классе приложения заменить статические словари на данные, получаемые из JetStream, и обновлять виджеты в `update_telemetry()`【177912408678874†L595-L633】.
4. Настроить периодическую обработку сообщений с помощью `asyncio.create_task` и передавать обновления в виджеты через `update_data()`.
5. При отсутствии данных выводить «Загрузка…» и отображать время последнего обновления.

### Ожидаемый результат
- Все панели отражают актуальные параметры корабля.
- Радар показывает реальные треки, а не статические примеры【177912408678874†L207-L215】.

## 3. Чат‑вкладка для общения с Q‑агентом

### Задача
Добавить отдельную панель для диалога с Q‑агентом, позволяя оператору писать сообщения и получать ответы прямо в консоли.

### Шаги
1. Создать новый виджет `ChatWidget` с областями «история сообщений» и «поле ввода».
2. Реализовать клиент (REST/gRPC/NATS) для отправки сообщений к агенту и получения ответов.
3. Добавить горячую клавишу (например, `F5`) для переключения между телеметрией и чатом.
4. Сохранять историю сообщений в памяти консоли и отображать метки времени, автора и языка.
5. Обрабатывать ошибки (не удалось отправить/получить) и выводить уведомления в журнал событий.

### Ожидаемый результат
- Оператор может вести полноценный диалог, не покидая TUI.
- Q‑агент корректно отвечает, а сообщения отображаются в реальном времени.

## 4. Командная палитра и горячие клавиши

### Задача
Сделать систему вызова команд удобной и расширяемой, чтобы оператор выполнял действия без длинных вводов.

### Шаги
1. Создать `CommandPaletteWidget` на основе `Textual` (`ListView` или `Menu`), вызываемый по `Ctrl+P`.
2. Перечислить команды с описаниями: изменение тяги, управление RCS, запуск/остановка сервисов, переключение автопилота, запрос текущих параметров и т.д.
3. Реализовать обработчики для каждой команды, используя методы `ShipActuatorController` и другие API【177912408678874†L688-L727】.
4. Обновить справку (`F1`) и панель горячих клавиш, указав новые сочетания клавиш【177912408678874†L467-L474】.

### Ожидаемый результат
- Оператор может быстро выбирать команды из списка и не вспоминать синтаксис.
- Статус последних команд отображается в `CommandInputWidget`.

## 5. Локализация и улучшение дизайна

### Задача
Повысить удобсто использования консоли за счёт поддержания нескольких языков и адаптивной верстки.

### Шаги
1. Создать модуль `i18n.py`, содержащий словари переводов для английского и русского языков.
2. Вынести все строки (заголовки, подписи, сообщения) в словари, вместо «жёстко» в коде.
3. Добавить переключатель языка (`Ctrl+L`), изменяющий текущий словарь и перерисовывающий интерфейс.
4. Использовать flex‑раскладку Textual (например, `Horizontal`, `Vertical` с `auto` высотой) для адаптивности окна.
5. Продумать цветовую схему: использовать яркие цвета для ошибок и предупреждений; придерживаться единой палитры.

### Ожидаемый результат
- Консоль красиво выглядит на разных размерах терминала.
- Пользователь может переключать язык интерфейса.

## 6. Тестирование и CI

### Задача
Обеспечить стабильность и соблюдение стандартов кода путём написания тестов и автоматических проверок.

### Шаги
1. Установить `pytest` и `pytest-textual` для тестирования интерфейса.
2. Написать unit‑тесты для:
   - функции `process_command` с различными комбинациями аргументов (успешные и ошибочные вызовы);
   - методов `update_data()` для каждого виджета (корректно ли обновляются состояния);
   - клиента JetStream и Event Store (моки/фиктивные данные).
3. Добавить pre‑commit‑конфигурацию: запуск Ruff (`ruff check`), Pylint (оценка ≥ 8/10) и Mypy.
4. Настроить GitHub Actions: запуск линтеров и тестов, проверка покрытия (`pytest --cov`) и сборка Docker‑образа.
5. Достигнуть порога покрытия не менее 80 %.

### Ожидаемый результат
- Каждый PR проходит автоматическую проверку и тесты; регрессии обнаруживаются на ранней стадии.

## 7. Документация

### Задача
Поддерживать актуальность документации для разработчиков и операторов.

### Шаги
1. Обновить `README.md` и `TASK_LIST.md`:
   - добавить раздел о консоли оператора, ёй архитектуре и назначении;
   - описать требования (Python 3.12, зависимости), установку и запуск;
   - перечислить доступные команды и горячие клавиши.
2. Создать новый файл `docs/task_plans/operator_console_next_steps.md` (или добавить в существующие планы), где зафиксировать этот план и трекер выполнения.
3. Нарисовать диаграмы (Mermaid) потоков данных между консолью, JetStream, Event Store и другими сервисами.
4. Обновить файлы `docs/agents` (шаблоны промптов) так, чтобы они учитывали новые задачи (чат, команда‑палитра, тесты).

### Ожидаемый результат
- Документация помогает быстро понять, что делает консоль и как её развивать.
- Задачи и зависимости прозрачны и согласованы с общим баклогом.

---

Этот план служит ориентиром для дальнейшего развития QIKI Mission Control TUI. Каждый пункт можно передавать в Warp как отдельный промпт для дальнейшей работы.Этот план служит ориентиром для дальнейшего развития QIKI Mission Control TUI. Каждый пункт можно передавать в Warp‑агента с соответствующим промптом, следуя определённым шагам и фиксируя ожидаемые результаты. Регулярное обновление планов и документации позволит команде синхронно развивать проект и поддерживать высокое качество кода.
