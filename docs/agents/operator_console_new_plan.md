# План развития QIKI Operator Console TUI

> NOTE (2026-01-20): this document describes an **alternate/legacy** console plan (Warp agent mode + gRPC client + panels).
> Current ORION “Shell OS” canon for QIKI_DTMP is in `docs/design/operator_console/*` and is NATS/Textual-first.
> Treat this file as **reference only** unless we explicitly decide (and record an ADR) to revive a gRPC-based operator console track.

Этот план предназначен для агентного режима в Warp и описывает ключевые задачи по дальнейшему развитию новой консоли оператора, расположенной в `src/qiki/services/operator_console`. Консоль уже имеет модульную архитектуру (`clients`, `ui`, `utils`) и реализует основные функции: телеметрию через NATS, чат с агентом, командную панель и вкладки интерфейса. План направлен на завершение интеграции, улучшение дизайна, плавность обновления и обеспечение качества. Все задачи предполагают использование Python 3.12, соблюдение PEP 8, проверку Ruff, оценку Pylint не ниже 8/10, тестирование PyTest с покрытием ≥ 80 и поддержку локализации (русский/английский).

## 1. Интеграция gRPC‑команд и чата

### Контекст

В текущей реализации `CommandPanel` и `ChatPanel` используют заглушки: команды только логируются, а сообщения чата не отправляются агенту【962600725637974†screenshot】【57721827561919†screenshot】. Нужно реализовать реальную связь с ядром QIKI для управления симуляцией и общения с агентом.

### Задача

Подключить к консоли gRPC‑клиент для отправки команд (start, pause, stop, export_telemetry, diagnostics, настройка аллокатора) и сообщений чата, а также получать ответы.

### Шаги

1. Изучить gRPC‑интерфейсы сервисов QIKI (симулятор, аллокатор, агент).
2. В папке `clients` добавить модуль `grpc_client.py`, который использует `grpc.aio` для асинхронных вызовов: `start_simulation()`, `pause()`, `stop()`, `export_telemetry()`, `diagnostics()`, `send_message()`.
3. В `CommandPanel` заменить вызовы логирования на вызовы `GrpcClient` и обработку ответов/ошибок:
   - при успешном завершении выводить сообщение о статусе и добавлять запись в `EventLog`;
   - при ошибке показывать всплывающее уведомление.
4. В `ChatPanel` реализовать метод `send_chat_message()`, который отправляет текст на сервер и показывает ответ агента в панели чата; предусмотреть отправку нескольких языков.
5. Добавить индикатор состояния gRPC (подключен/нет), который отображается в статусной панели.

### Ожидаемый результат

- Команды выполняются на ядре QIKI, а статус отображается в UI.
- Чат поддерживает двустороннее общение в реальном времени; сообщения и ответы логируются.

## 2. Реализация вкладок "метрики" и "настройки"

### Контекст

В текущей версии приложение содержит заглушки "Metrics visualization coming soon…" и "Settings panel coming soon…"【962600725637974†screenshot】. Для полноценного управления и наблюдения эти вкладки должны отображать подробные данные и позволять регулировать параметры системы.

### Задача

Реализовать панель метрик и панель настроек, интегрированные с хранилищем метрик (Prometheus) и конфигурацией сервиса.

### Шаги

1. Определить список метрик: задержка сообщений NATS, загрузка CPU/памяти, частота обновления треков, пропускная способность JetStream и др.
2. Добавить в `clients` модуль `metrics_client.py` для сбора метрик из NATS/Prometheus и внутренних датчиков.
3. Создать виджет `MetricsPanel` в `ui`, используя графики (например, `LineChart`) и таблицы; добавить периодический автообновление.
4. Разработать виджет `SettingsPanel`, который позволяет:
   - Выбирать URL NATS и gRPC.
   - Настраивать пороги предупреждений и критических уровней.
   - Изменять тему и шрифт UI.
5. Обеспечить сохранение настроек (config-file/database) и их загрузку при старте.

### Ожидаемый результат

- Вкладка "Метрики" отображает актуальные графики и таблицы.
- Вкладка "Настройки" позволяет изменять параметры подключения, операторского UI и сохраняет их.

## 3. Обработка ошибок и повторное подключение

### Контекст

Сейчас при ошибках соединения c NATS или gRPC исключения просто логируются【57721827561919†screenshot】.

### Задача

Улучшить стабильность консоли: реализовать текстовые уведомления, автоподключение при потере сессии и индикаторы состояния.

### Шаги

1. Добавить в `clients/nats_client.py` и `clients/grpc_client.py` логику reconnect: при потере соединения ожидать N секунд и повторять попытки.
2. В `OperatorConsoleApp` при возникновении исключений показывать пользователю toast-сообщение или snackbar.
3. Логировать все ошибки в файл и отображать опопрыдование (краткую сводку) в панели системного статуса.
4. Обновлять индикатор статуса соединений: зелёный при октомствий, красный при потере.

### Ожидаемый результат

- Консоль автовосстанавливает сервесы NATS/gRPC.
- Пользователь видит развернутые сообщения об ошибках и статусе соединения.

## 4. Улучшение дизайна и плавности обновления

### Контекст

Хотя новая консоль использует Rich и Textual, дизайн можно улучшить: фиксированные размеры панелей могут приводить к переполнению, таблицы «прыгают» при обновлении, а цветовая схема и шрифты не везде согласованы.

### Задача

Сделать интерфейс более эстетичным и плавным: адаптивные размеры, согласованная цветовая схема, плавное обновление компонент, локализация.

### Шаги

1. Использовать `flex` и `grid` в CSS Textual для адаптивного распределения пространства.
2. Настроить `refresh_per_second` для `Live` и других обновляемых компонентов, чтобы минимизировать мерцание【896881600398357†L48-L83】.
3. Подобрать палитру цветов, выделяя основные статусы: зелёный для ОК, жёлтый для предупреждений, красный для ошибок.
4. Вынести тексты (панели и меню) в файл локализации (JSON/YAML) и добавить переключатель языка в `SettingsPanel`.
5. Добавить контроль видимости панелей: открывать и закрывать панели по горячим клавишам.

### Ожидаемый результат

- Интерфейс масштабируется и плавно обновляется.
- Цвета передают статусную информацию.
- Пользователь может выбрать язык и управлять панелями.

## 5. Дополнительные функции и будущие улучшения

### Контекст

Консоль может стать платформой для плагинов и новых датчиков.

### Задача

Определить новый функционал и заложить точки расширения.

### Шаги

1. Добавить вкладку «History» с виджетом просмотра истории треков и телеметрии.
2. Реализовать экспорт данных в CSV/JSON и выгрузку логов.
3. Подготовить API для плагинов, таких как ML-классификаторы или новые сенсоры.
4. Продумать «wizard»-режим: пошаговые сценарии для запуска миссий и калибровки.

### Ожидаемый результат

- Консоль является расширяемой: добавление новых вкладок и модулей возможно без переделки ядра.
- Пользователь может анализировать историю и экспорировать данные.

## 6. Тестирование и CI

### Контекст

Чтобы защититься от регрессий, нужны модульные тесты и проверки стиля.

### Задача

Настроить модульные тесты и CI/CD для консоли.

### Шаги

1. Писать unit-тесты для `clients`, `utils` и основных виджетов; использовать `pytest` и `pytest-textual`.
2. Сконфигурировать Ruff и Pylint; добиваться оценки не ниже 8/10.
3. Добавить `pytest-cov` для измерения покрытия; настроить pre-commit hooks.
4. Наладить GitHub Actions для запуска линтеров и тестов при каждом PR.

### Ожидаемый результат

- Консоль покрыта модульными тестами и проверками стиля.
- CI запускается каждый раз при создании pull‑request.

## 7. Документация

### Контекст

Необходимо обновить документы и подготовить справочник для операторов.

### Задача

Актуализировать README, TASK_LIST и design-docs.

### Шаги

1. Описать новую консоль в README: запуск, вкладки, горячие клавиши.
2. Добавить новые задачи в TASK_LIST и TASK_DETAILS.
3. Создать отчёт `docs/console_architecture.md` с диаграммой.
4. Обновлять `operator_console_new_plan.md` поэтапно.
5. Разработать руководство для операторов.

### Ожидаемый результат

- Документы свежие и описывают новую консоль.
- Задачи в TASK_LIST/TASK_DETAILS отражают текущий статус.

### Заключение

Реализуя каждую задачу согласно плану, вы переведёте минимальную телеметрическую консоль во полнофункциональный и гибкий инструмент для операторов QIKI. Принцип модульности и параллельной работы агентов сохранит масштабируемость проекта.
