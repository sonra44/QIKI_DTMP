# План реализации консоли оператора (Agent Console) для QIKI\_DTMP

## Цель

Создать независимый микросервис "консоль оператора", который будет отображать телеметрию, обеспечивать диалог с Q\-агентом и позволять выполнять быстрые команды через терминальный интерфейс. Консоль должна быть реализована на Python 3.12 с использованием библиотеки **Rich** и фреймворка **Textual** для построения текстового пользовательского интерфейса (TUI) и работать асинхронно. Код должен соответствовать стандарту PEP 8 (проверка Ruff), иметь оценку качества кода по Pylint не ниже 8/10 и покрытие тестами PyTest не менее 80 %.

## Этапы реализации

1. **Анализ требований и подготовка среды**
   - Изучите текущие документы проекта (`README.md`, `TASK_LIST.md`, `TASK_DETAILS.md`, `RADAR.md`, `bot_gdd.md`) и выделите данные, которые должны отображаться в консоли: состояние FSM, треки радара и метрики JetStream, события Guard Rules, параметры аллокатора тяги, состояние батарей и другие сервисы.
   - Определите команды, которые должна выполнять консоль (старт/стоп симулятора, перезапуск аллокатора, переключение режимов радара, запрос состояния и др.).
   - Создайте новую папку/микросервис (например, `operator_console`) в репозитории, настроенный на Python 3.12. Добавьте зависимости: `rich`, `textual`, `asyncio`, `nats-py` (для NATS JetStream), `grpcio` и `protobuf` (для gRPC), а также dev‑зависимости: `ruff`, `pylint`, `pytest`, `pytest-cov`, `pre-commit`.
   - Настройте `pre-commit` для запуска Ruff и PyTest локально перед коммитами.

2. **Настройка Docker и CI**
   - Создайте `Dockerfile` для консоли и отдельный `docker-compose.operator.yml`, чтобы можно было поднять сервис изолированно. В `docker-compose` подключите JetStream, gRPC‑сервисы и Event Store, если требуется.
   - Обновите CI (GitHub Actions) для нового сервиса: добавьте шаги для `ruff check`, `pylint` (с порогом ≥ 8), `pytest --cov=operator_console` (с порогом покрытия ≥ 80 %) и сборки Docker‑образа.
   - Обновите `TASK_LIST.md`/`TASK_DETAILS.md`, описав задачи по разработке консоли.

3. **Имплементация клиента NATS/JetStream и gRPC**
   - Реализуйте асинхронный модуль `clients/nats_client.py` для подписки на JetStream: подключайтесь к брокеру, подписывайтесь на нужные потоки (`RADAR_SR`, `RADAR_LR`, события FSM, Guard Rules и т. д.) и передавайте сообщения в обработчики UI.
   - Реализуйте `clients/grpc_client.py` на основе сгенерированных stubs gRPC для взаимодействия с Q\-агентом: методы отправки команд (run/stop), запросы текущего состояния, отправка вопросов для диалога. Добавьте функции для обработки ответов.
   - Покройте оба клиента unit‑тестами (можно использовать `pytest` и `pytest-asyncio`), создав моки NATS и gRPC.

4. **Проектирование структуры TUI**
   - Используйте **Textual** для организации интерфейса. Определите основные виджеты:
     - **Панель телеметрии**: отображает таблицу/графики в реальном времени. Используйте `rich.table.Table` и класс `Live` из Rich для динамического обновления【896881600398357†L48-L83】. Обновляйте таблицу при получении новых сообщений из JetStream.
     - **Панель чата**: окно для ввода естественного языка и вывода ответов от агента. Ввод может использовать TextInput из Textual; история диалога отображайте в ScrollView.
     - **Командная палитра/меню**: список доступных команд с описанием и горячими клавишами. Реализуйте автодополнение и поиск через Textual.
     - **Навигация**: настройте горячие клавиши (например, `Ctrl+T` для переключения на чат, `Ctrl+M` для меню, `Ctrl+L` для телеметрии). Используйте систему событий Textual для переключения фокуса.
   - Спроектируйте layout (grid/Rows/Columns), чтобы панели могли автоматически подстраиваться под размер терминала.

5. **Интеграция событий и обновление UI**
   - В основном приложении запускайте несколько асинхронных задач: подписка на JetStream, прием сообщений от gRPC и обработка пользовательского ввода. Обновляйте соответствующие виджеты через `call_from_thread` или события Textual.
   - Для телеметрии: при получении сообщения обновляйте таблицу/графики; используйте `live.update()`【896881600398357†L48-L83】.
   - Для чата: отправляйте введённые строки через gRPC‑клиент и отображайте ответы в истории.
   - Для команд: при выборе команды публикуйте соответствующее сообщение в JetStream или вызывайте gRPC‑метод, затем подтверждайте результат.

6. **Тестирование**
   - Создайте unit‑тесты для каждого компонента: клиентов, парсеров сообщений, логики обновления UI. Используйте `pytest` и `pytest-asyncio` для асинхронных функций.
   - Напишите интеграционные тесты для проверки взаимодействия с настоящими или мок‑версиями NATS/JetStream и gRPC (можно использовать тестовые контейнеры). Проверьте подписку, отправку команд и отображение данных.
   - Используйте `pytest-cov` для измерения покрытия; целью является ≥ 80 %.
   - Запускайте Ruff и Pylint как часть тестов; убедитесь, что нет ошибок PEP 8 и оценка Pylint не ниже 8.

7. **Документация и примеры**
   - Обновите `docs/` с описанием запуска консоли: объясните, как поднять сервис (локально и в Docker), какие зависимости установить и как подключиться к JetStream/gRPC.
   - Опишите все команды и горячие клавиши, приведите пример диалога с агентом и покажите, как читать телеметрию.
   - Добавьте раздел в `WARP.md` или `AGENTS.md`, чтобы агенты Warp понимали, что консоль — это отдельный сервис, и знали, как к нему обращаться.

8. **План итераций**
   - **Итерация 1**: вывести базовую телеметрию в таблице (без чата и команд); подписка на один поток JetStream; минимальные тесты.
   - **Итерация 2**: добавить чат с Q‑агентом через gRPC; реализовать простой обработчик команд (start/stop).
   - **Итерация 3**: расширить набор метрик (скорости, углы, состояние батарей), добавить графики и панели; создать командную палитру с горячими клавишами.
   - **Итерация 4**: интегрировать Guard Rules события, треки радара и действия аллокатора; завершить тестирование и улучшить UI.
   - На каждой итерации запускайте полный набор тестов, Ruff и Pylint, фиксируйте достигнутое покрытие и оценку качества.

## Заключение

Следуя этому плану, агент в Warp сможет шаг за шагом реализовать консоль оператора как отдельный TUI‑микросервис. Такой подход позволит контролировать качество кода, покрытие тестами и стабильность работы, а использование Rich и Textual обеспечит удобный и гибкий интерфейс. В будущем на основе общего API можно будет создать веб‑оболочку, если возникнет необходимость.
