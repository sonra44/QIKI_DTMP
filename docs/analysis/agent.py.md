# Анализ файла: `services/q_core_agent/core/agent.py`

**Версия документации:** 1.0  
**Дата анализа:** 2025-09-03

---

## 1. Назначение и Архитектурная Роль

Этот файл определяет класс `QCoreAgent`, который является **центральным "мозгом" или "нервной системой"** всей системы. Его основная роль — не выполнять сложную бизнес-логику самостоятельно, а **оркестрировать** взаимодействие между всеми остальными специализированными компонентами.

**Архитектурная роль:** Реализация паттерна **Координатор (Coordinator)** или **Посредник (Mediator)**. `QCoreAgent` является центральной точкой, которая управляет потоком данных и вызовов между различными подсистемами (обработчиками, движками решений), не позволяя им напрямую взаимодействовать друг с другом. Это упрощает архитектуру и снижает зацепление (coupling) между компонентами.

---

## 2. Ключевые Классы

-   **`AgentContext`**: Простой `dataclass`, который служит для хранения временного состояния в рамках **одного "тика"** (одного цикла обработки). Он содержит последние полученные данные о статусе BIOS, состоянии FSM и "предложениях". Это позволяет передавать единый объект контекста в разные компоненты, а не множество отдельных параметров.

-   **`QCoreAgent`**: Основной класс, который:
    -   Инициализирует все необходимые обработчики и движки (`BiosHandler`, `FSMHandler`, `RuleEngine` и т.д.).
    -   Содержит основную логику жизненного цикла агента (`run_tick`).
    -   Управляет `AgentContext`.

---

## 3. Логика Рабочего Цикла ("Тика")

Основная работа агента происходит в методе `run_tick`, который вызывается внешним `TickOrchestrator`. Этот метод выполняет строгую последовательность действий:

1.  **`_update_context(data_provider)`**: **Сбор информации.** Агент запрашивает самые свежие данные у `IDataProvider` и сохраняет их в `self.context`.

2.  **`_handle_bios()`**: **Проверка "железа".** Агент передает статус BIOS специализированному `BiosHandler` для обработки.

3.  **`_handle_fsm()`**: **Определение состояния.** Агент передает текущее состояние FSM в `FSMHandler`, который определяет, должно ли состояние измениться.

4.  **`_evaluate_proposals()`**: **Генерация идей.** Агент запрашивает "предложения" о дальнейших действиях у `RuleEngine` (на основе правил) и `NeuralEngine` (на основе ML-моделей). Затем все эти предложения передаются в `ProposalEvaluator` для выбора наилучшего.

5.  **`_make_decision()`**: **Принятие решения и действие.** Агент берет лучшее из выбранных предложений и отдает соответствующие команды низкоуровневому `BotCore` для исполнения.

---

## 4. Принципы Проектирования и Реализация

### 4.1. Делегирование и Принцип Единственной Ответственности (SRP)

-   **Как реализовано:** `QCoreAgent` не пытается делать все сам. Логика обработки BIOS вынесена в `BiosHandler`, логика FSM — в `FSMHandler`, генерация предложений — в `RuleEngine` и `NeuralEngine`. Сам агент лишь вызывает их в правильном порядке.
-   **Почему это важно:** Каждый класс имеет одну, четко определенную зону ответственности. Это делает код более понятным, тестируемым и легким для модификации.

### 4.2. Отказоустойчивость (Fault Tolerance)

-   **Как реализовано:** Каждый шаг в `run_tick` обернут в блок `try...except`. В случае сбоя любого компонента (например, `FSMHandler` выбрасывает исключение), агент вызывает метод `_switch_to_safe_mode()`.
-   **Почему это важно:** Это базовый, но критически важный механизм надежности. Вместо полного падения всего приложения при ошибке в одном из модулей, агент переходит в безопасное состояние, логирует ошибку и может продолжить работу в ограниченном режиме или ожидать исправления.

---

## 5. Взаимодействие с Другими Модулями

-   **`tick_orchestrator.py`**: `TickOrchestrator` является внешним компонентом, который вызывает `agent.run_tick()` в бесконечном цикле.
-   **`interfaces.py`**: `QCoreAgent` сильно зависит от интерфейсов (`IDataProvider`, `IBiosHandler` и т.д.) для взаимодействия со своими компонентами. Он не знает о конкретных реализациях, что позволяет легко их подменять.
-   **`bot_core.py`**: `BotCore` используется как самый низкий уровень абстракции для отправки команд на "железо" или в симулятор.
-   **Все обработчики и движки**: `QCoreAgent` владеет экземплярами всех обработчиков (`FSMHandler`, `BiosHandler`) и движков (`RuleEngine`, `NeuralEngine`) и вызывает их методы.
