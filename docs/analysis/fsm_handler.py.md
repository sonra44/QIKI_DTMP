# Анализ файла: `services/q_core_agent/core/fsm_handler.py`

**Версия документации:** 1.0  
**Дата анализа:** 2025-09-03

---

## 1. Назначение и Архитектурная Роль

Этот файл определяет класс `FSMHandler`, который является **"хранителем логики состояний"** агента. Его единственная и четко определенная ответственность — вычислять, в какое следующее состояние должен перейти конечный автомат (FSM) на основе текущего состояния и внешних условий.

**Архитектурная роль:** Реализация паттерна **Состояние (State)** и **Принципа Единственной Ответственности (Single Responsibility Principle)**. Вся сложная логика принятия решений о смене состояний инкапсулирована в этом одном классе. Это делает поведение агента предсказуемым и легко изменяемым: чтобы поменять логику FSM, нужно изменить только этот файл.

---

## 2. Детальный Разбор Логики Переходов

Вся логика переходов централизована в приватном методе `_compute_transition_dto`. Он принимает текущее состояние и условия, а возвращает новое состояние и причину перехода. Правила четко определены:

-   **Из `BOOTING` (Загрузка):**
    -   **Если** `bios_ok` (все системы в порядке) → перейти в `IDLE` (Ожидание). **Причина:** `BOOT_COMPLETE`.
    -   **Иначе** → перейти в `ERROR_STATE` (Ошибка). **Причина:** `BIOS_ERROR`.

-   **Из `IDLE` (Ожидание):**
    -   **Если** `bios_ok` **и** `has_proposals` (появились предложения от движков решений) → перейти в `ACTIVE` (Активен). **Причина:** `PROPOSALS_RECEIVED`.
    -   **Если** `bios` не в порядке → перейти в `ERROR_STATE`.

-   **Из `ACTIVE` (Активен):**
    -   **Если** `bios_ok` **и** `not has_proposals` (предложения закончились) → перейти в `IDLE` (Ожидание). **Причина:** `NO_PROPOSALS`.
    -   **Если** `bios` не в порядке → перейти в `ERROR_STATE`.

-   **Из `ERROR_STATE` (Ошибка):**
    -   **Если** `bios_ok` (проблема устранена) **и** нет предложений → перейти в `IDLE` (Ожидание). **Причина:** `ERROR_CLEARED`.

---

## 3. Интеграция со `StateStore`

`FSMHandler` является основным **"писателем"** в `AsyncStateStore`. Этот процесс реализован в асинхронном методе `process_fsm_dto`:

1.  **Получение текущего состояния:** Метод принимает на вход текущий `FsmSnapshotDTO`.
2.  **Вычисление перехода:** Вызывает `_compute_transition_dto`, чтобы определить, каким должно быть следующее состояние.
3.  **Создание нового снимка:** Если состояние изменилось, создает новый объект `TransitionDTO` и использует фабричную функцию `next_snapshot()` из `types.py` для создания нового, консистентного снимка состояния с увеличенной версией.
4.  **Запись в хранилище:** Вызывает `await self.state_store.set(new_dto)`, чтобы атомарно обновить состояние в центральном хранилище. Этот вызов, в свою очередь, уведомляет всех подписчиков о произошедшем изменении.

---

## 4. Обратная Совместимость

-   **Метод `process_fsm_state`**: Этот синхронный метод оставлен для обратной совместимости с "legacy"-режимом, который не использует `StateStore`. Он работает напрямую с изменяемыми Protobuf-объектами, что является менее надежным подходом, но позволяет системе функционировать в упрощенной конфигурации.

---

## 5. Взаимодействие с Другими Модулями

-   **`agent.py`**: `QCoreAgent` вызывает `fsm_handler.process_fsm_dto()` в каждом "тике".
-   **`store.py`**: `FSMHandler` является основным клиентом, который записывает данные в `AsyncStateStore`.
-   **`types.py`**: Глубоко зависит от DTO-объектов и фабричных функций (`FsmState`, `TransitionDTO`, `next_snapshot`, `create_transition`).
-   **`interfaces.py`**: Реализует интерфейс `IFSMHandler`.
