# Анализ файла: `services/q_core_agent/main.py`

**Версия документации:** 1.0  
**Дата анализа:** 2025-09-03

---

## 1. Назначение и Архитектурная Роль

Этот файл является **главной точкой входа ("сборочным цехом")** для микросервиса `Q-Core Agent`. Его основная задача — инициализировать, сконфигурировать и запустить все необходимые компоненты агента в правильном порядке. Он не содержит бизнес-логики, а только собирает вместе все части системы (`Agent`, `DataProvider`, `TickOrchestrator`, `StateStore`) и запускает основной рабочий цикл.

**Архитектурная роль:** Реализация паттерна **Composition Root**. Вся "проводка" зависимостей (Dependency Injection) происходит в одном месте, что делает остальную систему чистой и независимой от деталей конфигурации и запуска.

---

## 2. Логика Запуска и Конфигурация

Скрипт предоставляет несколько гибких способов запуска, управляемых через аргументы командной строки и переменные окружения.

### 2.1. Выбор Режима Работы (через `argparse`)

Скрипт использует стандартную библиотеку `argparse` для определения, в каком режиме должен работать агент:

-   **`--mock`**: Запускает агента в **тестовом режиме**. В этом случае используется `MockDataProvider`, который поставляет заранее определенные, "поддельные" данные. Это позволяет тестировать логику агента в полной изоляции, без необходимости запускать симулятор (`Q-Sim Service`).
-   **`--grpc`**: Запускает агента в **сетевом режиме**. Используется `GrpcDataProvider`, который подключается к `Q-Sim Service` по сети через gRPC. Это основной режим для распределенной работы.
-   **По умолчанию (Legacy режим)**: Если ни один флаг не указан, используется `QSimDataProvider`, который напрямую взаимодействует с экземпляром `QSimService` в том же процессе. Это полезно для простой локальной отладки.

### 2.2. Выбор Архитектуры Состояния (через `os.environ`)

Скрипт проверяет переменную окружения `QIKI_USE_STATESTORE`. Это работает как **feature flag** для переключения между двумя архитектурами:

-   **Если `QIKI_USE_STATESTORE=true`**: Включается **современная, асинхронная архитектура**. Создается `AsyncStateStore`, и запускается асинхронный цикл `run_with_statestore`. Это основной режим для надежной работы.
-   **Если флаг отсутствует или `false`**: Используется **устаревшая, синхронная архитектура**. `StateStore` не создается, и запускается простой цикл `while True`.

### 2.3. Безопасное Завершение Работы

-   **Как реализовано:** Используется стандартная библиотека `signal` для перехвата сигналов `SIGINT` (Ctrl+C) и `SIGTERM`.
-   **Почему это важно:** Это признак production-ready приложения. При получении сигнала на завершение, программа не падает, а вызывает функцию `handle_shutdown`, которая логирует событие и корректно завершает процесс. Это предотвращает потерю данных и оставление "зомби"-процессов.

---

## 3. Ключевые Функции

-   **`main()`**: Основная функция. Парсит аргументы, настраивает логирование, обрабатывает сигналы, загружает конфигурацию, создает все объекты и запускает главный цикл.
-   **`load_config(path)`**: Загружает конфигурацию из `config.yaml`.
-   **`_create_mock_bios_status()` / `_create_mock_fsm_state()`**: Фабричные функции, которые создают реалистичные mock-объекты для тестового режима. Это хороший пример вынесения логики создания тестовых данных из основного кода.
-   **`run_with_statestore(...)`**: Асинхронный рабочий цикл, который использует `TickOrchestrator` для выполнения "тиков" и `AsyncStateStore` для получения актуального состояния FSM.

---

## 4. Взаимодействие с Другими Модулями

Этот файл является центральной точкой, которая импортирует и связывает все остальные компоненты:

-   **`agent.py`**: Создает экземпляр `QCoreAgent`.
-   **`interfaces.py`**: Создает одну из реализаций `IDataProvider` (`MockDataProvider`, `GrpcDataProvider`, `QSimDataProvider`).
-   **`tick_orchestrator.py`**: Создает `TickOrchestrator`.
-   **`store.py`**: Создает `AsyncStateStore` через `create_initialized_store()`.
-   **`os`, `sys`, `argparse`, `yaml`, `signal`**: Активно взаимодействует со стандартными библиотеками Python для работы с операционной системой, аргументами, файлами и сигналами.
