# Анализ файла: `services/q_core_agent/state/store.py`

**Версия документации:** 1.0  
**Дата анализа:** 2025-09-03

---

## 1. Назначение и Архитектурная Роль

Этот файл определяет класс `AsyncStateStore`, который является **сердцем всей архитектуры управления состоянием** в проекте. Его основная задача — служить централизованным, потокобезопасным и асинхронным хранилищем для состояния конечного автомата (FSM) агента.

**Архитектурная роль:** Реализация паттерна **"Единственный источник правды" (Single Source of Truth, SSOT)**. Любой компонент системы, которому необходимо узнать текущее состояние агента, обращается к этому хранилищу. Это исключает рассинхронизацию и повреждение данных, которые могли бы возникнуть при передаче объекта состояния по цепочке вызовов.

---

## 2. Ключевые Классы

-   **`AsyncStateStore`**: Основной класс, реализующий хранилище.
-   **`StateStoreError(Exception)`**: Базовое исключение для всех ошибок, связанных с хранилищем.
-   **`StateVersionError(StateStoreError)`**: Специализированное исключение, которое выбрасывается при попытке записать устаревшую версию состояния.

---

## 3. Принципы Проектирования и Реализация

### 3.1. Потокобезопасность и Защита от Гонок Данных

-   **Как реализовано:** Все операции чтения (`get`) и записи (`set`) защищены асинхронной блокировкой `asyncio.Lock()`.
-   **Почему это важно:** Гарантирует, что только одна корутина может изменять состояние в один момент времени. Это полностью исключает **гонки данных (race conditions)**, когда несколько частей программы одновременно пытаются записать разные данные, что могло бы привести к неконсистентному или поврежденному состоянию.

### 3.2. Версионирование и Оптимистичные Блокировки

-   **Как реализовано:** Каждый снимок состояния (`FsmSnapshotDTO`) имеет поле `version`. При каждом успешном вызове `set()` версия автоматически увеличивается. Метод `set()` также имеет флаг `enforce_version=True`, который принудительно проверяет, что записываемая версия новее текущей.
-   **Почему это важно:** Это механизм **оптимистичной блокировки**. Он предотвращает проблему **"потерянных обновлений"**. Если два компонента одновременно прочитают состояние версии `N`, а затем попытаются записать новую версию, только первый успеет записать версию `N+1`. Второй, попытавшись записать свою версию `N+1`, получит ошибку `StateVersionError`, так как текущая версия в хранилище уже будет `N+1`.

### 3.3. Система Уведомлений (Publisher/Subscriber)

-   **Как реализовано:** Через методы `subscribe()` и `unsubscribe()`. Любой компонент может подписаться на обновления и получить `asyncio.Queue`. При каждом вызове `set()` `AsyncStateStore` рассылает новый снимок состояния всем подписчикам в их очереди.
-   **Почему это важно:** Это позволяет построить **реактивную, событийно-ориентированную архитектуру**. Компоненты не опрашивают состояние в цикле (polling), а реагируют на его изменение. Это более эффективно и упрощает логику.
-   **Отказоустойчивость:** Метод `_notify_subscribers` спроектирован так, чтобы один "медленный" или "мертвый" подписчик (чья очередь переполнена или недоступна) не мог заблокировать или сломать всю систему уведомлений. Проблемные подписчики логируются и удаляются из списка.

### 3.4. Работа с Неизменяемыми DTO

-   **Как реализовано:** `AsyncStateStore` работает исключительно с `FsmSnapshotDTO` из модуля `types.py`, которые являются неизменяемыми (`frozen=True`).
-   **Почему это важно:** Хранилище не беспокоится о том, что кто-то может случайно изменить объект состояния после его получения. Это является ключевым элементом для предсказуемости потока данных.

---

## 4. Детальный Разбор Методов

-   **`__init__(self, initial_state)`**: Инициализирует `asyncio.Lock`, внутреннее хранилище `_snap`, список подписчиков `_subscribers` и словарь для метрик `_metrics`.
-   **`get(self)`**: Атомарно возвращает текущий снимок состояния.
-   **`set(self, new_snap, enforce_version)`**: Основной метод записи. Выполняет проверку версионности, автоинкремент версии, сохраняет новый снимок и вызывает `_notify_subscribers`.
-   **`subscribe(self, subscriber_id)`**: Добавляет новую очередь в список подписчиков и немедленно отправляет в нее текущее состояние.
-   **`unsubscribe(self, queue)`**: Безопасно удаляет подписчика из списка.
-   **`initialize_if_empty(self)`**: Устанавливает начальное состояние (`COLD_START`), если хранилище пусто.
-   **`get_metrics(self)` / `health_check(self)`**: Методы для самодиагностики и мониторинга, предоставляющие информацию о времени работы, количестве операций, конфликтах версий и т.д.

---

## 5. Взаимодействие с Другими Модулями

-   **`services/q_core_agent/state/types.py`**: Напрямую зависит от `FsmSnapshotDTO` и `initial_snapshot`.
-   **`services/q_core_agent/core/fsm_handler.py`**: Является основным **"писателем"** в `AsyncStateStore`.
-   **`services/q_core_agent/core/tick_orchestrator.py`**: Управляет вызовами `AsyncStateStore` в асинхронном режиме работы.
-   **`asyncio`**: Глубоко интегрирован с библиотекой `asyncio` для реализации блокировок и очередей.
