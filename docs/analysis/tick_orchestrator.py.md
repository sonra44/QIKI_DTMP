# Анализ файла: `services/q_core_agent/core/tick_orchestrator.py`

**Версия документации:** 1.0  
**Дата анализа:** 2025-09-03

---

## 1. Назначение и Архитектурная Роль

Этот файл определяет класс `TickOrchestrator`, который является **"дирижером" или "метрономом"** для `QCoreAgent`. Его единственная и четко определенная задача — управлять основным рабочим циклом ("тиком") агента.

**Архитектурная роль:** Реализация принципа **Разделения Ответственности (Separation of Concerns)**. `TickOrchestrator` отделяет логику *управления жизненным циклом* от *бизнес-логики* агента.
-   `QCoreAgent` знает, **ЧТО** делать в рамках одного тика.
-   `TickOrchestrator` знает, **КОГДА** и **КАК** запустить этот тик, а также что делать до и после него (логирование, обработка ошибок).

Такое разделение делает систему более чистой, гибкой и тестируемой. `QCoreAgent` можно тестировать в изоляции, просто вызывая его методы, а `TickOrchestrator` можно тестировать с "поддельным" агентом.

---

## 2. Детальный Разбор Режимов Работы

`TickOrchestrator` спроектирован для работы в двух режимах, что отражает эволюцию архитектуры проекта от простой синхронной модели к более сложной и надежной асинхронной.

### 2.1. Асинхронный Режим (`run_tick_async`)

-   **Как активируется:** Через переменную окружения `QIKI_USE_STATESTORE=true`.
-   **Как работает:** Это основной, современный режим. Оркестратор вызывает асинхронные методы и работает в связке с `AsyncStateStore`. Ключевое отличие в том, что состояние FSM не запрашивается у `DataProvider`, а получается напрямую из `StateStore` (`await self.state_store.get()`).
-   **Зачем это нужно:** Этот режим полностью отвязывает логику состояний от поставщика данных. Агент может получать сенсорные данные из одного источника, а состояние FSM — из другого (например, из персистентного хранилища). Это основа для построения распределенной и отказоустойчивой системы.

### 2.2. Синхронный "Legacy" Режим (`run_tick`)

-   **Как активируется:** Используется по умолчанию, если `StateStore` не включен.
-   **Как работает:** Это более простой, синхронный режим. Оркестратор вызывает метод `agent._update_context()`, который запрашивает *все* данные, включая состояние FSM, напрямую у `DataProvider`.
-   **Зачем это нужно:** Обеспечивает обратную совместимость и предоставляет более простую модель для базовых сценариев или отладки, не требующих сложного управления состоянием.

---

## 3. Ключевые Функции и Особенности

### 3.1. Структурированное Логирование Производительности

-   **Как реализовано:** В конце каждого тика (и в синхронном, и в асинхронном режиме) оркестратор собирает и логирует детальную информацию о производительности. Он измеряет и записывает общую длительность тика, а также длительность каждой отдельной фазы (`update_context`, `handle_bios`, `handle_fsm` и т.д.) в миллисекундах.
-   **Почему это важно:** Это бесценный инструмент для **профилирования и отладки**. Если система начинает работать медленно, эти логи немедленно покажут, какая именно фаза стала "узким местом".

### 3.2. Централизованная Обработка Ошибок

-   **Как реализовано:** Весь рабочий цикл внутри `run_tick` и `run_tick_async` обернут в один блок `try...except Exception as e`.
-   **Почему это важно:** Это гарантирует, что сбой в **любом** из компонентов агента не приведет к падению всего сервиса. Оркестратор перехватит исключение, вызовет метод `agent._switch_to_safe_mode()`, залогирует ошибку и сделает паузу перед следующим тиком. Это обеспечивает базовый уровень отказоустойчивости.

---

## 4. Взаимодействие с Другими Модулями

-   **`main.py`**: Создает экземпляр `TickOrchestrator`, передавая ему ссылку на созданного агента, конфигурацию и, опционально, `StateStore`.
-   **`agent.py`**: `TickOrchestrator` владеет экземпляром `QCoreAgent` и вызывает его публичные и внутренние (начинающиеся с `_`) методы в определенном порядке.
-   **`store.py`**: В асинхронном режиме напрямую взаимодействует с `AsyncStateStore` для получения актуального состояния FSM.
-   **`interfaces.py`**: Получает реализацию `IDataProvider` от `main.py` и передает ее в методы агента.
