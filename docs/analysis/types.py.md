# Анализ файла: `services/q_core_agent/state/types.py`

**Версия документации:** 1.0  
**Дата анализа:** 2025-09-03

---

## 1. Назначение и Архитектурная Роль

Этот файл является **фундаментом всей системы управления состоянием**. Он определяет канонические, внутренние структуры данных (DTOs - Data Transfer Objects), которые используются ядром `Q-Core Agent`.

**Архитектурная роль:**
1.  **Определение "Истины":** Эти классы являются единственным источником правды для внутреннего представления состояния. Вся бизнес-логика оперирует только этими объектами.
2.  **Изоляция от Деталей Реализации:** Самое важное — эти классы **полностью независимы от формата сериализации** (например, Protobuf). Это позволяет ядру системы оставаться чистым и не зависеть от того, как данные передаются по сети. Если завтра проект перейдет с Protobuf на JSON, изменения не затронут основную логику, а только слой конвертации (`conv.py`).
3.  **Гарантия Неизменяемости:** Все DTO в этом файле спроектированы как **неизменяемые (immutable)**, что является краеугольным камнем для построения надежных и предсказуемых многопоточных/асинхронных систем.

---

## 2. Ключевые Классы и Перечисления

-   **`FsmState(IntEnum)`**: Жестко заданный, исчерпывающий список всех возможных состояний конечного автомата (FSM). Использование `IntEnum` обеспечивает как читаемость (`FsmState.IDLE`), так и эффективность.

-   **`TransitionStatus(IntEnum)`**: Определяет возможные исходы перехода из одного состояния в другое (`SUCCESS`, `FAILED`, `PENDING`).

-   **`TransitionDTO(frozen=True)`**: Неизменяемый объект, представляющий один конкретный переход FSM. Он фиксирует, *из какого* состояния, *в какое*, по какой *причине* (`trigger_event`) и с каким *статусом* произошел переход. Автоматически проставляет временные метки `ts_mono` (монотонное время для порядка) и `ts_wall` (реальное время для логов).

-   **`FsmSnapshotDTO(frozen=True)`**: **Основной и самый важный объект.** Это неизменяемый "снимок" полного состояния FSM в определенный момент времени. Он содержит:
    -   `version`: Версия состояния для оптимистичных блокировок.
    -   `state`: Текущее состояние (`FsmState`).
    -   `prev_state`: Предыдущее состояние.
    -   `reason`: Человеко-читаемая причина последнего изменения.
    -   `history`: Неизменяемый кортеж (`Tuple`) из `TransitionDTO`, хранящий историю переходов.
    -   `context_data` / `state_metadata`: Словари для хранения дополнительных данных.
    -   `snapshot_id` / `fsm_instance_id`: Уникальные идентификаторы.

---

## 3. Принципы Проектирования и Реализация

### 3.1. Неизменяемость (Immutability)

-   **Как реализовано:** Все `dataclass` определены с параметром `frozen=True`. Это стандартный механизм Python, который запрещает изменение полей объекта после его создания. Любая попытка присвоить новое значение полю вызовет исключение `FrozenInstanceError`.
-   **Почему это важно:** Это **ключевое архитектурное решение**. Оно полностью исключает целый класс трудноотлавливаемых ошибок, когда разные части программы могли бы случайно изменить один и тот же объект состояния, что в асинхронной среде привело бы к хаосу. Вместо изменения объекта, система создает его новую копию с обновленными данными.

### 3.2. Целостность Данных при Создании

-   **Как реализовано:** В методе `__post_init__` каждого `dataclass` происходит автоматическая инициализация ключевых полей, если они не были предоставлены. Например, `history` и `context_data` инициализируются пустыми коллекциями, а `snapshot_id` и временные метки `ts_mono`/`ts_wall` генерируются автоматически.
-   **Почему это важно:** Это гарантирует, что каждый созданный объект состояния является полным и консистентным. Разработчику не нужно помнить о ручной инициализации всех полей.

---

## 4. Фабричные Функции (Factory Functions)

Вместо того чтобы позволять разработчикам вручную создавать DTO в любом месте кода, модуль предоставляет три "фабричные" функции. Это централизует и стандартизирует процесс создания и обновления состояний.

-   **`initial_snapshot()`**: Создает самый первый, "нулевой" снимок состояния (`version=0`, `state=BOOTING`, `reason="COLD_START"`). Гарантирует, что любая FSM всегда начинается с одной и той же, четко определенной точки.

-   **`create_transition(...)`**: Простая вспомогательная функция для чистого и консистентного создания объектов `TransitionDTO`.

-   **`next_snapshot(current, new_state, ...)`**: **Самая важная функция в модуле.** Это единственный правильный способ создать новое состояние на основе предыдущего.
    -   **Логика версионирования:** Функция сама проверяет, изменилось ли состояние (`new_state != current.state`). Версия (`version`) увеличивается **только в случае реального изменения состояния**. Если состояние не изменилось, версия остается прежней. Это предотвращает "шум" в версиях.
    -   **Сохранение истории:** Корректно добавляет новый переход в историю.
    -   **Сохранение целостности:** Копирует важные данные из предыдущего снимка в новый (например, `fsm_instance_id`, `context_data`), гарантируя, что контекст не будет потерян при переходе.

---

## 5. Взаимодействие с Другими Модулями

-   **`store.py`**: `AsyncStateStore` хранит и оперирует экземплярами `FsmSnapshotDTO`.
-   **`fsm_handler.py`**: Использует `next_snapshot()` для вычисления следующего состояния на основе текущего.
-   **`conv.py`**: Отвечает за преобразование `FsmSnapshotDTO` и `TransitionDTO` в их Protobuf-эквиваленты и обратно.
-   **Все тесты (`tests/`)**: Используют эти DTO и фабричные функции для создания тестовых сценариев.
