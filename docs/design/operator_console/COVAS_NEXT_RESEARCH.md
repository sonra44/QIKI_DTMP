# COVAS:NEXT — Research Notes (влияние на ORION/QIKI)

**Что это:** COVAS:NEXT — ассистент для Elite: Dangerous с инструментами (actions), UI-оверлеем/табами контекста, реакциями на события и plugin API.

**Зачем нам:** это практический пример “AI‑copilot + высокочастотные события + UI‑оболочка”, близкий к нашему ORION/QIKI.

---

## 1) Actions/Tools как “контракт управления” (важно)

COVAS:NEXT формализует действия как **Actions/Tools** (команды/функции), которые ассистент может вызывать по намерению пользователя, и подчёркивает зависимость выполнения от “правильных биндов” (keyboard binds). Это прямо соответствует нашей цели: ORION отправляет Intent, QIKI превращает в Proposal/Command, а исполнение проходит через разрешённые “инструменты”.

**Что перенять в ORION/QIKI:**
- Разделить “Intent” (свободный ввод) и “Tool/Action execution” (строго типизированный контракт).
- Завести **диагностику prerequisites**: какие бинды/возможности доступны, какие конфликтуют, чего не хватает (аналог “bindings overview / collisions” в их UI и Actions‑доках).
- Сделать “Quick actions/хоткеи” в ORION как тонкую обвязку вокруг типизированных intents.

---

## 2) “Real‑time visualization of LLM context” → “покажи, что знает QIKI”

В COVAS:NEXT есть ставка на **визуализацию контекста**, который уходит в LLM (отдельные UI‑табы состояния/локации и т.п.). Это снижает ощущение “магии” и помогает отладке: оператор видит, какие факты ассистент использует.

**Что перенять:**
- В ORION добавить экран/панель “QIKI Context/Контекст QIKI” (как принцип).
- На первом этапе достаточно: показывать последнюю “карточку” контекста (snapshots + режим FACTORY/MISSION + свежесть) и “последний intent → proposals”.

---

## 3) Plugin API: расширяемость без хаоса

COVAS:NEXT имеет plugin API с понятными точками расширения:
- register_actions (инструменты),
- projections (агрегация состояния),
- sideeffects (реакции на события),
- prompt/status generators (добавление в контекст/память, с учётом token cost),
- should_reply handlers (гейтинг “отвечать/молчать”).

**Что перенять:**
- В QIKI сделать похожую архитектуру модулей: “адаптеры/плагины” добавляют источники состояния и tools, а ядро остаётся стабильным.
- Явно учитывать стоимость контекста: что попадает в промпт, что остаётся в состоянии/хранилище.

---

## 4) LLM Internals: надёжность tool‑use и “модели притворяются”

Их доки подчёркивают, что tool‑use надёжен только когда:
1) провайдер поддерживает function calling,
2) модель реально обучена на tool‑use,
3) провайдер валидирует tool calls (например, строгий режим).

Плюс практический кейс: слабые модели могут “согласиться” выполнить, но не вызвать action — это важно диагностировать в UI.

**Что перенять:**
- Это прямое обоснование нашего решения: “proposals‑only сначала” + строгий JSON/валидатор.
- В ORION нужно показывать: был ли реально отправлен command/tool‑call, или это только текст.

---

## 5) Arbitration / “Dominant mode” (когда несколько ассистентов)

В интеграциях COVAS:NEXT описан “dominant mode”: кто “говорит” и кто “молчит”, чтобы избежать взаимного перебивания.

**Что перенять:**
- Для ORION/QIKI: единый “output arbiter” (в FACTORY можно больше шума, в MISSION — строгий гейтинг).
- Для событий: категории/мьют + incidents (мы уже в эту сторону идём).

---

## 6) Memory/Logbook (долгая память ассистента)

У них есть “Logbook” и выбор embedding provider: память отдельна от UI и может быть запросима.

**Что перенять:**
- Для QIKI: отдельный “операционный журнал/логбук” (не путать с sovereign-memory; sovereign-memory — для разработки/межсессий человека и агента).
- В FACTORY логбук помогает отладке: “почему приняла решение”, “какие инциденты уже видела”.

