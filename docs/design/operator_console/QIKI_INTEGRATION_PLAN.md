# QIKI ↔ ORION — План подключения “мозга” (без развилок)

**Цель:** ORION остаётся “операторской оболочкой”, а QIKI (q_core_agent) становится владельцем управления: интерпретирует намерения, предлагает действия, применяет ограничения FSM и (позже) исполняет команды.

**Канонический контракт (MVP → рост):** `docs/design/operator_console/CANONICAL_SPEC_ORION_QIKI.md`

---

## 1) Где “мозг” уже предусмотрен в проекте

QIKI логически живёт в `q_core_agent`:

- Агентный цикл: `src/qiki/services/q_core_agent/core/tick_orchestrator.py`
- Сбор контекста/мир-модель: `src/qiki/services/q_core_agent/core/agent.py`
- Дет. безопасность: `RuleEngine` (`src/qiki/services/q_core_agent/core/rule_engine.py`)
- Точка расширения под AI: `NeuralEngine` (`src/qiki/services/q_core_agent/core/neural_engine.py`) — сейчас заглушка

ORION не должен быть мозгом; он UI + визуализация + операторский ввод.

---

## 2) Контракт “Intent → Proposals → Decision → (later) Commands”

### 2.1 Intent (из ORION в QIKI)

ORION публикует **намерение** (RU/EN текст + контекст UI):
- `text` (сырой ввод)
- `lang_hint` (`ru`/`en`/`auto`)
- `screen`/`selection` (что было выделено)
- `ts`

MVP (факт по текущей реализации) использует pub/sub с корреляцией по `request_id`:
- intents: `qiki.intents`
- responses: `qiki.responses.qiki`

Публичные стримы для аудита/телеметрии допускаются позже, но не нужны для первого запуска.

### 2.2 Proposals (ответ QIKI)

QIKI возвращает список предложений:
- `title` (коротко, двуязычно)
- `justification` (почему, двуязычно)
- `confidence/priority`
- `proposed_actions` (на первом этапе **пусто**)

Важно: для ORION удобнее, если все human-facing строки приходят как `{ "en": "...", "ru": "..." }`, а ORION форматирует их как `EN/RU`.

### 2.3 Decision / решение оператора (MVP)

MVP уже включает “approval step”, но **без исполнения**:

- ORION позволяет оператору принять/отклонить выбранное предложение (accept/reject) через UI.
- ORION публикует follow-up intent в `qiki.intents`, ссылаясь на `proposal_id` (в текущей реализации это текст вида `proposal accept <id>` / `proposal reject <id>`).
- Это **не запускает никаких auto-actions** и не отправляет control-команды.

### 2.4 Execute / исполнение (позже)

Только в отдельной фазе (после политики допуска и явного “разрешения на исполнение”) QIKI сможет формировать/отправлять команды на control bus:

- `qiki.commands.control` → ответы в `qiki.responses.control`

---

## 3) Подключение OpenAI (когда будем готовы)

Встраивать OpenAI не в ORION, а в `NeuralEngine`:

1) Конфиг через ENV (не в git): `OPENAI_API_KEY`, модель, таймауты, лимиты частоты.
2) Строгий формат ответа модели: **JSON only** → маппинг в `Proposal`.
3) Guardrails:
   - таймаут + fallback (если LLM умер — система работает без него)
   - запрет автодействий на первом этапе (`proposed_actions=[]`)
   - логирование без секретов

---

## 4) Линейный порядок внедрения (минимально рискованный)

1) ORION: публикация Intent **без UI mode toggle**:
   - оператор вводит QIKI intent через префикс `q:` или `//`,
   - ORION публикует Intent и логирует подтверждение в `Output/Вывод`.
2) QIKI: добавить приём Intent и генерацию “заглушечного” Proposal (без OpenAI) → ORION отображает.
3) QIKI: включить OpenAI в `NeuralEngine` (только предложения).
4) Позже (отдельная фаза): typed actions/команды/исполнение.

---

## 5) Режимы QIKI и Policy (Factory/Завод vs Mission/Миссия)

Идея: QIKI должна **знать**, что сейчас она “на заводе” (разработка/тестирование), а не “в космосе”.
Это не должно быть только текстом в промпте — это часть *системного состояния* и *политики допуска*.

### 5.1 Канонические режимы (MVP)

- `FACTORY/ЗАВОД` — разработка, валидация, отладка, безопасные проверки.
- `MISSION/МИССИЯ` — реальная эксплуатация, строгие ограничения, минимум шума.

Опционально позже: `SIM/СИМУЛЯЦИЯ`, `MAINTENANCE/ОБСЛУЖИВАНИЕ`.

### 5.2 Что меняется от режима (обязательные отличия)

**FACTORY/ЗАВОД**
- Разрешены “инженерные” операции: self-test, диагностика, прогон сценариев, сбор метрик.
- Разрешены подробные объяснения/логирование.
- Действия, влияющие на мир/актуаторы: либо запрещены, либо требуют `approve`.
- Допускаются “проверочные” intents (например “проверь контракт”, “сгенерируй тест”, “объясни почему stale”).

**MISSION/МИССИЯ**
- Минимизировать несущественный вывод.
- Любые “опасные” команды — только через строгий allowlist и/или многоступенчатое подтверждение.
- Полная трассировка (audit trail) и идемпотентность команд важнее “красивого ответа”.

### 5.3 Где хранить режим (чтобы он был истиной)

Рекомендуемый подход:
- Режим хранится в QIKI как “system state” (и публикуется наружу как snapshot), а ORION **только отображает**.
- ORION показывает режим явно в header (например `FACTORY/ЗАВОД`).
- Любой Intent включает `environment_mode`, но QIKI не обязана ему верить — она проверяет против своего состояния.

### 5.4 Политика допуска (gating) для первых запусков

Для быстрой проверки интеграции предлагается “безопасный старт”:
- LLM/NeuralEngine может выдавать **только Proposals** (`proposed_actions=[]`).
- Исполнение команд системой остаётся либо выключенным, либо требует явного `approve`.

---

## 6) Управление временем симуляции (концепция “active pause”)

Концепция: оператор/ORION может **поставить мир на активную паузу**, ввести команду/намерение, дать QIKI “подумать/спланировать”, затем продолжить симуляцию в realtime.

### 6.1 Текущий статус в коде (важно)

- В ORION уже есть команды: `simulation.start/симуляция.старт`, `simulation.pause/симуляция.пауза`, `simulation.stop/симуляция.стоп`, `simulation.reset/симуляция.сброс` (они публикуются в control bus как `sim.*`).
- `q_sim_service` принимает `sim.start/sim.pause/sim.stop/sim.reset` через `qiki.commands.control` и управляет фактическим тикающим циклом (active pause: world step + radar publish останавливаются при `sim.pause`).

### 6.2 Что нужно добавить, чтобы “active pause” стало реальным

Рекомендуемая реализация (MVP):
- В `q_sim_service` добавить состояние:
  - `run_state`: `RUNNING/PAUSED/STOPPED`
  - `time_scale`: `float` (например `0.0`=пауза, `1.0`=realtime, `4.0`=ускорение)
- В loop симуляции применять:
  - если `PAUSED` → не вызывать `world_model.step()`, но продолжать принимать intents/команды управления
  - если `RUNNING` → `world_model.step(delta_time * time_scale)`
- На control bus (или отдельный sim-control subject) повесить реальные handlers для:
  - `sim.pause`, `sim.resume`, `sim.stop`, `sim.reset`
  - опционально `sim.step` (один тик), `sim.timescale <x>`

### 6.3 Почему это важно для QIKI

LLM/планирование может занимать секунды. Без “active pause” мир успевает измениться, а предложения становятся устаревшими.
Пауза позволяет:
- сделать “think → plan → execute” детерминированным в тестовых прогонов,
- потом вернуться в realtime.
