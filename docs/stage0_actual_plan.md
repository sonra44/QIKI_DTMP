# Этап-0 (актуализация) — минимальный план внедрения

## Контекст и мотивация
- Исторический сценарий «Этап-0» подразумевал построение каркаса с нуля, однако Phase 1 уже реализует radar pipeline, docker-compose, shim-пакеты и базовые метрики.
- Полный откат к исходному чек-листу приведёт к повторной работе, массовым рефакторам протоколов (`protos/**`) и временной потере работоспособности.
- Задача: выделить необходимые недостающие элементы из 0_step.md и внедрить их инкрементально поверх текущего стека, не ломая существующие контракты.

## Цели
1. Формализовать спецификацию BotSpec и связать её с runtime-конфигами.
2. Стандартизировать событийную шину (JetStream) и регистратор с учётом CloudEvents-метаданных.
3. Усилить наблюдаемость и контроль backpressure.
4. Автоматизировать smoke-проверку «минимальной вселенной» в CI.

## Обязательные внедрения

### 1. BotSpec + валидатор
- Артефакты: `shared/specs/BotSpec.yaml`, `shared/models/bot_spec.py` (Pydantic v2), unit-тесты в `tests/shared/test_bot_spec_validator.py`.
- Функция: гарантировать наличие обязательных компонент и каналов, выдавать runtime-конфиги `services/*/config/*.json`.
- DoD: `python -m pytest -q tests/shared/test_bot_spec_validator.py` зелёный; BotSpec интегрирован в docker-compose (стартовые сервисы читают единый профиль).

### 2. Событийные контракты и метаданные
- Конвертация текущих protobuf тем (`qiki.radar.v1.*`, `qiki.events.v1.audit`) в вид, совместимый с CloudEvents: заголовки `ce_id`, `ce_type`, `ce_source`, `ce_time`.
- Обновить `tools/js_init.py` и FastStream handlers для установки/чтения метаданных.
- DoD: e2e-тест (`tests/integration/test_event_metadata.py`) получает событие из JetStream и проверяет наличие CloudEvents-полей.

### 3. Backpressure и JetStream политики
- Зафиксировать `ack_wait`, `max_deliver`, `max_ack_pending` и retention для тем в `ops/nats/jetstream-init.sh`.
- Добавить мониторинг lag через Prometheus (`qiki_jetstream_consumer_lag`), экспорт в WorldModel/bridge.
- DoD: контейнерный smoke (`make smoke` внутри `qiki-dev`) отображает стабильный lag < заданного порога, метрики видны на `/metrics`.

### 4. Registrar и аудит
- Вынести регистратор в сервис `services/registrar/` с API приёма событий и записью в `qiki.events.v1.audit` + локальный файл с ротацией.
- Коды диапазонов (1xx…9xx) оформить отдельным модулем, добавить Pydantic-модели и тест (`tests/unit/test_registrar_codes.py`).
- DoD: при запуске smoke сценария появляются события `BOOT_OK`, `SENSOR_IO_OK`; тест на диапазоны проходит.

### 5. CI / smoke автоматизация
- Добавить цель `make smoke`, которая поднимает docker-compose Phase 1, выполняет health-check, ожидает ≥1 сообщения в `qiki.radar.v1.frames`, проверяет регистратор.
- Интегрировать `make smoke` в CI (условный job, запускаемый по label `smoke`).
- DoD: локальный запуск `make smoke` (в контейнере `qiki-dev`) завершает цикл без ошибок; CI job помечен как обязательный перед релизом.

## Не входит в текущий этап
- Переписывание существующих protobuf пакетов (`protos/radar/v1`, `common_types_pb2.py`) и shim-пакетов.
- Полный редизайн q_core_agent или world model.
- Визуализация радара и расширенный трекинг (отдельный backlog Phase 2).

## Риски и меры
- **Риск:** нарушение обратной совместимости protobuf → **Мера:** только добавление новых полей/хедеров, без изменения существующих контрактов.
- **Риск:** рост времени CI из-за `make smoke` → **Мера:** ограничить сценарий минимальным набором проверок и использовать кеш контейнеров.
- **Риск:** дублирование конфигураций → **Мера:** BotSpec становится источником правды; runtime-конфиги генерируются из него.

## План интеграции
1. Реализовать BotSpec и валидатор (параллельно подготовить пример конфига).
2. Добавить CloudEvents-метаданные и соответствующие тесты.
3. Обновить JetStream init и метрики; проверить лаги.
4. Выделить регистратор в отдельный сервис и подключить к шине.
5. Настроить `make smoke` и включить в CI.

Каждый шаг закрывается обновлением документации (`CLAUDE_MEMORY.md`, `CURRENT_STATE.md`, журналы) и прохождением обязательных проверок (`ruff`, `mypy`, `pytest`).
