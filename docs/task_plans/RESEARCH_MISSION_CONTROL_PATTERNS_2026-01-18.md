# Research — Mission Control / Ground Systems паттерны для ORION (2026-01-18)

Цель: зафиксировать обзор того, как обычно устроены “настоящие” mission control / ground systems, и что из этого применимо к **QIKI_DTMP** **без нарушения** наших инвариантов:

- **no-mocks**: UI показывает только simulation-truth; если источника нет → честное `N/A/—`.
- **no-v2**: не создаём `*_v2.*` и не плодим новые параллельные subject’ы/контракты ради удобства.
- **no-duplicates / single source of truth**: один канон данных (runtime SoT — `bot_config.json`), без дублей “спецификаций”.

---

## 1) Источники (что именно было просмотрено)

Ниже — ссылки на публичные системы/доки, из которых извлечены паттерны:

1) COSMOS — Limits Monitor (концепт “держать алерт, пока оператор явно не обработает”)
- https://ballaerospace.github.io/cosmos-website/docs/v5/limits-monitor

2) Yamcs — Parameter Archive / статус параметров (value + status + applied limits + processing status)
- https://docs.yamcs.org/yamcs-server-manual/data-management/parameter-archive/

3) NASA Open MCT — единый UI для live + history (time conductor, layout, timelines)
- https://nasa.github.io/openmct/

4) NATS subjects — гигиена subject’ов: коротко, без “данных” в subject, payload/headers вместо этого
- https://docs.nats.io/nats-concepts/subjects

5) Textual DataTable — особенности/ограничения таблиц (важно при росте данных)
- https://textual.textualize.io/widgets/data_table/

Дополнительно (потенциальное ускорение DataTable при росте строк):
- https://github.com/tconbeer/textual-fastdatatable

---

## 2) Паттерны, которые стоит перенять (самое полезное)

### 2.1 Limits/Alerts как отдельный слой

**Идея (COSMOS):** монитор лимитов — это не “ещё одно поле в таблице”. Это отдельный операционный слой:
- показывает только то, что “вышло за предел” (warning/critical),
- держит инцидент “живым” пока оператор не выполнит действие (ack/hide/ignore),
- не скрывает проблему просто потому, что “таблица обновилась”.

**Польза для ORION:** снимает нагрузку с “Diagnostics” и делает UX реально операторским.

### 2.2 Статус параметра хранится рядом со значением

**Идея (Yamcs):** у каждого параметра хранится не только engineering value, но и:
- timestamp,
- parameter status (OK/WARN/FAIL/UNKNOWN/processing),
- “какие лимиты применялись” в момент измерения,
- при желании raw value (у нас это может быть не нужно на MVP).

**Польза для ORION:** даже при no-mocks можно честно объяснять “почему красное” и “почему N/A”.

### 2.3 Один UI должен уметь и live, и history (архитектурно)

**Идея (Open MCT):** time conductor и единая модель отображения позволяют:
- живой поток,
- историю,
- процедуры/таймлайн,
в одном интерфейсе.

**Польза для ORION:** даже если мы не внедряем историю “сейчас”, важно проектировать так, чтобы это было возможно позже (без ломки контрактов).

### 2.4 Subject hygiene

**Идея (NATS):**
- subject должен быть коротким, стабильным, с ограниченным числом токенов;
- не кодировать “данные” в subject (например, не делать subject вида `qiki.telemetry.sensor.imu_main.temp.42.3`),
- переносить детали в payload/headers.

**Польза для QIKI_DTMP:** мы уже делаем правильно (`qiki.telemetry`, `qiki.events.v1.*`, `qiki.commands.control`). Важно удержать эту дисциплину, иначе subject’ы разрастутся и начнут ломать экосистему.

### 2.5 Производительность таблиц

**Идея (Textual DataTable):**
- таблица — удобный MVP, но при больших объёмах (история / сотни сенсоров / тысячи инцидентов) может стать bottleneck.

**Польза для ORION:** пока таблицы небольшие — ок. При росте стоит заранее иметь план:
- пагинация,
- “backend model” и рендер только видимой области,
- отдельные специализированные виджеты.

---

## 3) Что можно улучшить у нас без “ломки архитектуры”

Ниже — рекомендации, совместимые с текущими правилами (**no-mocks / no-v2 / no-duplicates**).

### 3.1 Добавить “status/limits слой” в телеметрию сенсоров (Yamcs-подобно)

**Цель:** рядом со значением иметь статус и причину.

**Предложение формата (без новых subject’ов):**
- остаёмся в `qiki.telemetry` как top-level extra keys,
- расширяем `sensor_plane.*` так, чтобы у каждого блока были:
  - `value`/`reading` (что уже есть),
  - `status`: `ok|warn|crit|na`,
  - `reason`: строка (почему статус такой),
  - (опционально) `limits`: границы, применённые “сейчас”.

**No-mocks правило:**
- если нет источника → `status=na`, `value` отсутствует/`null`, `reason="no source"`.

**Почему это важно:** UI перестаёт быть “таблицей чисел” и становится “операторским диагностическим прибором”.

### 3.2 Сделать отдельный экран ORION “Limits/Alerts”

**Цель:** выделить инциденты лимитов и держать их до явного ack/hide.

**Минимальный MVP:**
- новый экран в ORION (без новых subject’ов),
- вход: текущая `qiki.telemetry` + правила лимитов (из конфигов),
- выход: UI список активных отклонений (warning/critical) + действия (ack/hide).

### 3.3 Подготовить дорожку к history/replay (без обязательной Grafana прямо сейчас)

**Варианты (закладывать концепт, не обязательно внедрять сегодня):**
- JetStream как “replay window” для событий/телеметрии (проще, ближе к NATS экосистеме),
- TSDB (Grafana/Loki/Prometheus) для метрик и долгой истории (позже).

**Важно:** не плодить v2-контракты под history; history — это слой хранения/реплея, а не новый формат событий.

### 3.4 Держать subjects стабильными и короткими

Продолжать текущую дисциплину:
- семантика в payload,
- subjects: `qiki.telemetry`, `qiki.events.v1.*`, `qiki.commands.control`.

### 3.5 План на масштабирование таблиц

Когда количество строк станет большим:
- рассмотреть “быструю таблицу” / виртуализацию строк,
- отделить “операторский список инцидентов” от “полной матрицы всех параметров”.

---

## 4) Вердикт по текущему направлению QIKI_DTMP

Текущее направление **правильное** и совместимо с индустриальными паттернами:

- `sensor_plane.*` как extra key в `qiki.telemetry` + честное `N/A/—` при отсутствии источника — это “не врать оператору”.
- Стабильные subjects и семантика в payload — правильная “subject hygiene”.
- Следующее качественное усиление — “status/limits слой”, который превращает мониторинг в управляемую операционную систему.

---

## 5) Рекомендуемый следующий шаг (минимально рискованный)

Сделать **минимальный status/limits слой для Sensor Plane**:

1) Определить лимиты и статус-поля для 2–3 ключевых параметров (например: радиация, температура узлов, IMU health).
2) Эмитить `status/reason` рядом со значениями в `qiki.telemetry` (без новых subject’ов).
3) Отобразить в ORION:
   - либо внутри `Sensors`,
   - либо отдельным экраном “Limits/Alerts” (если хотим операторский UX сразу).

Критерий успеха: оператор видит не только “число”, но и “почему жёлто/красно/na” без моков и без хака контрактов.

