# ТЗ (MVP): BIOS виртуализации “железа” QIKI (без дублей, без v2)

Цель этого документа — дать **автономное** и **регламентное** ТЗ для независимой модели‑исполнителя (например, Claude 4.5), которая **не видит репозиторий**.  
ТЗ ориентировано на проект **QIKI_DTMP** и обязано соблюсти **no-mocks policy** в UI: показываем только реальные данные симуляции или честное `N/A`.

---

## 0) Контекст и принципы (не обсуждается)

1) Проект — **симуляция** (Digital Twin). Всё “железо бота” виртуальное.  
2) Метрики CPU/RAM **не берутся из ОС/VPS**, а вычисляются как **simulation-truth** (уже реализовано отдельно).  
3) **Запрещено** создавать дубли и “новые версии” ради удобства:
   - нельзя добавлять `*_v2.*`, `bios_status_v2.*`, “второй bot_spec”, “альтернативный hardware_profile”.
   - если чего-то не хватает — расширяем **существующие** каноничные артефакты/контракты, либо добавляем **новое** (но без параллельных источников правды).
4) BIOS — обязательный слой, который должен появиться **до** глубокой виртуализации двигателей/энергосистемы/тепла/стыковки.

---

## 1) Каноничные документы и артефакты (источник правды)

Исполнитель обязан ориентироваться на эти файлы/идеи (в реальном репо они существуют):

**Текстовый SoT (человекочитаемый):**
- `docs/design/hardware_and_physics/bot_source_of_truth.md` — единый источник правды по структуре “железа” и пайплайну профиля.
- `docs/design/q-core-agent/bios_design.md` — дизайн BIOS как низкоуровневого слоя.

**Машиночитаемые артефакты (приоритет выше текста):**
- `src/qiki/services/q_core_agent/config/bot_config.json` — runtime hardware profile (уже используется в логике).
- `shared/specs/BotSpec.yaml` — декларативная карта компонентов (what exists, provides/consumes).
- `config/propulsion/thrusters.json` — RCS геометрия/лимиты (для следующих этапов, не в этом MVP).

**Политика контрактов:**
- `docs/CONTRACT_POLICY.md` — общий подход к эволюции контрактов.

---

## 2) Проблема, которую решаем в этом MVP

Сейчас BIOS‑статус в агенте/провайдерах фактически **мокается** (генерируется локально), из‑за чего:
- нет единого “правильного” BIOS‑источника;
- нельзя честно отображать BIOS‑готовность/ошибки в ORION;
- дальнейшая виртуализация подсистем не может опираться на единый POST‑репорт.

Нужно внедрить **реальный BIOS‑источник внутри симуляции** (virtual BIOS), который:
- читает hardware‑профиль,
- выполняет POST (детерминированные проверки),
- публикует отчёт,
- позволяет агенту/консоли получать этот отчёт без моков.

---

## 3) Объём работ (Scope)

### 3.1. Must-have (обязательно)
1) Реализовать сервис/компонент **BIOS MVP** (virtual firmware).
2) BIOS должен читать профиль “железа” из **каноничного** файла (см. раздел 1).
3) BIOS должен выполнять **POST** (Power‑On Self‑Test) по компонентам профиля.
4) BIOS должен публиковать **BiosStatus**:
   - доступен агенту (Q‑Core Agent) без моков,
   - доступен ORION (Operator Console) без моков.
5) ORION должен показывать BIOS‑статус **честно**: `OK/FAIL` или `N/A` если источника нет.
6) Всё должно подниматься/проверяться в Docker (Docker-first).

### 3.2. Out of scope (явно НЕ делаем в этом MVP)
- Реальный “железный” доступ (I2C/SPI/real sensors).
- Полная виртуализация Power/Thermal/RCS/Docking (будет следующим этапом).
- Изменение `.proto` схем и генерация новых версий (`v2`) ради BIOS.
- “Красивые” демо‑значения в UI вместо `N/A`.

---

## 4) Требования к данным (BiosStatus)

В проекте есть Pydantic‑модель BIOS статуса (примерное имя): `qiki.shared.models.core.BiosStatus`:
- `bios_version: str`
- `firmware_version: str`
- `post_results: list[DeviceStatus]`
- `timestamp: datetime`
- вычисляемое поле `all_systems_go: bool` (в модели)

И есть `DeviceStatus`:
- `device_id: str`
- `device_name: str`
- `status: enum` (`OK/DEGRADED/ERROR/UNKNOWN` в Pydantic-модели)
- `status_message: str | null`

**MVP правило:** BIOS возвращает JSON, совместимый с этой Pydantic‑моделью (не требуется Protobuf на этом этапе).

Допускается добавлять **дополнительные ключи** (forward‑compatible), но:
- нельзя ломать существующую структуру;
- нельзя вводить параллельный формат “bios_status_v2”.

---

## 5) Источник состава оборудования (как извлечь список устройств)

В `bot_config.json` присутствуют как минимум:
- `bot_id`, `bot_type`, `mode`, `schema_version`
- `hardware_profile.sensors[]` и `hardware_profile.actuators[]`
- `hardware_manifest` с ключевыми подсистемами (mainboard/mcqpu/power_plane/sensor_suite/rlsm)

**MVP правило:** список устройств для POST формируем как объединение:
1) `hardware_profile.sensors[]` + `hardware_profile.actuators[]`
2) `hardware_manifest` (разворачиваем вложенные структуры в список устройств)

---

## 6) POST (Power-On Self-Test): правила и алгоритм (MVP)

POST — это **детерминированные проверки**, основанные на реальном состоянии симуляции/конфига.

### 6.1. Виды проверок (минимум)
1) **Проверка конфигурации:** файл профиля читается, JSON валиден, обязательные ключи присутствуют.
2) **Проверка наличия устройств:** каждое устройство из профиля попадает в `post_results`.
3) **Проверка доступности симуляции (опционально, но желательно):**
   - если BIOS в отдельном сервисе: он должен проверить, что может связаться с критичным сервисом симуляции (например, `q-sim-service` health endpoint / gRPC HealthCheck).

### 6.2. Статусы (MVP)
- Если устройство есть в профиле и критичная связность есть → `OK`.
- Если устройство отсутствует/непарсится/профиль пуст → `ERROR` (а для конкретного устройства `ERROR` или `UNKNOWN`).
- Если критичный сервис недоступен → для критичных контроллеров `ERROR`, для остальных — `UNKNOWN` + пояснение.

### 6.3. “Честность” данных
Никакой случайной генерации “для красоты”. Если симуляция/сервисы не готовы — BIOS говорит об этом явно.

---

## 7) Архитектура реализации (как именно встроить BIOS)

### Вариант A (предпочтительный): отдельный сервис `q-bios-service`
Требования:
- отдельный python‑сервис в `src/qiki/services/q_bios_service/`
- запускается в docker‑стеке (добавить в `docker-compose.phase1.yml`)
- имеет HTTP API:
  - `GET /healthz` → `{"ok": true}`
  - `GET /bios/status` → JSON BiosStatus
- публикует событие в NATS:
  - subject: `qiki.events.v1.bios_status`
  - payload: JSON BiosStatus

### Вариант B (упрощённый): BIOS как часть `q-sim-service`
Допустим только если отдельный сервис слишком тяжёлый, но он хуже архитектурно.

---

## 8) Интеграция с Q‑Core Agent (убрать моки)

Сейчас провайдеры BIOS генерируют “реалистичный мок”. В MVP нужно:
- заменить источник BIOS на вызов BIOS сервиса `GET /bios/status`
- при недоступности BIOS сервиса:
  - **не подставлять мок**,
  - возвращать честный статус “нет данных” (например, пустой список `post_results` → `all_systems_go=False` и message в логах).

Рекомендуемые ENV:
- `BIOS_URL` (пример: `http://q-bios-service:8080`)

---

## 9) Интеграция с ORION (Operator Console)

ORION уже читает телеметрию/ивенты из NATS.

MVP требование:
- ORION показывает BIOS:
  - если видел событие `qiki.events.v1.bios_status` → показывает `BIOS OK` или `BIOS FAIL` (EN/RU формат строки).
  - если событий не было → `BIOS N/A`.

Важно:
- никакой “симпатичной заглушки”.
- если BIOS не поднят, UI должен честно показать `N/A`.

---

## 10) Тесты и критерии приёмки (Acceptance Criteria)

### 10.1. Unit-тесты (минимум)
1) `q-bios-service` корректно парсит `bot_config.json` и выдаёт `BiosStatus` JSON.
2) При отсутствии обязательных ключей в профиле — сервис возвращает `ERROR` в `post_results` (или общий статус через сообщения) и `all_systems_go` становится `false`.

### 10.2. Docker-интеграция
1) `docker compose -f docker-compose.phase1.yml up -d` поднимает `q-bios-service` вместе со стеком.
2) ORION (`operator-console`) показывает BIOS статус (OK/FAIL или N/A честно).

### 10.3. Definition of Done
- Нет новых `v2` файлов/схем.
- Нет “дублирующих” источников правды.
- Нет моков в BIOS источнике: данные либо реально выведены из профиля/сервисов, либо `N/A`.
- Прогон тестов зелёный (как минимум новые unit‑тесты + существующие смоки, которые затрагиваются).

---

## 11) Ограничения по изменениям (чтобы не сломать проект)

Исполнитель **не имеет права**:
- менять существующие темы NATS (`qiki.radar.v1.*`, `qiki.telemetry`) или вводить `v2` subject’ы;
- менять структуру `bot_config.json` несовместимо;
- добавлять новые “SoT” документы вместо правок каноничных;
- внедрять “моки” в UI.

---

## 12) Ожидаемый список файлов (ориентир)

Минимальный набор изменений, который допускается:
- `src/qiki/services/q_bios_service/...` (новый сервис)
- `docker-compose.phase1.yml` (добавить сервис BIOS)
- `src/qiki/services/q_core_agent/core/interfaces.py` или провайдеры (замена моков на BIOS URL)
- `src/qiki/services/operator_console/...` (минимальная подписка/отображение BIOS статуса)
- `tests/...` (unit тесты BIOS сервиса)
- `docs/operator_console/REAL_DATA_MATRIX.md` (обновить таблицу источников, если добавляем BIOS событие)

---

## 13) Команды для локальной проверки (в Docker)

Примерный сценарий:
1) `docker compose -f docker-compose.phase1.yml up -d --build`
2) `docker compose -f docker-compose.phase1.yml exec qiki-dev pytest -q`
3) `docker compose -f docker-compose.phase1.yml -f docker-compose.operator.yml up -d operator-console`
4) `docker attach qiki-operator-console`

---

## 14) Что прислать на ревью (артефакты)

Исполнитель должен вернуть:
- список изменённых файлов,
- короткое “как запустить/проверить”,
- вывод `pytest` (или что было запущено),
- подтверждение, что не добавлялись `v2`/дубли.

