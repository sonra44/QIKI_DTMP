# ТЗ (MVP, STEP‑A): Propulsion / RCS виртуализации “железа” QIKI (без дублей, без v2)

Цель: зафиксировать **регламентное** ТЗ для внедрения виртуализации RCS (reaction control system, 16 сопел) в проекте **QIKI_DTMP** так, чтобы:
- соблюсти **no‑mocks policy** (в UI только реальные данные симуляции или честное `N/A/—`);
- не создавать **дубли** и “вторые источники правды”;
- не добавлять `*_v2.*` и параллельные контракты/subject’ы.

ТЗ написано так, чтобы его можно было показать стороннему инженеру/модели без доступа к репозиторию.

---

## 0) Контекст (не обсуждается)

1) Проект — **симуляция / Digital Twin**. “Железо” бота виртуальное.  
2) “Реальные данные” в рамках проекта — это **simulation‑truth** (детерминированно вычисленные величины), а **не** метрики VPS/контейнера.  
3) **Запрещено**:
   - добавлять `*_v2.*` (например, `rcs_v2`, `propulsion_v2`, `telemetry_v2` и т.п.);
   - заводить второй `bot_config`/`bot_spec`/`thrusters_spec` с дублирующим содержимым.
4) Разрешено:
   - расширять **существующий** `src/qiki/services/q_core_agent/config/bot_config.json` новыми параметрами;
   - использовать **существующий** `config/propulsion/thrusters.json` как единственный источник геометрии/лимитов сопел (без копирования списка в другие файлы);
   - расширять **существующую** телеметрию `qiki.telemetry` дополнительными ключами верхнего уровня (в `TelemetrySnapshotModel` разрешены `extra`).

---

## 1) Каноничные документы/артефакты (источник правды)

**Текстовый SoT (человекочитаемый):**
- `docs/design/hardware_and_physics/bot_source_of_truth.md`
- `docs/operator_console/REAL_DATA_MATRIX.md`

**Машиночитаемые (приоритет выше текста):**
- `src/qiki/services/q_core_agent/config/bot_config.json` — runtime профиль “железа” (параметры RCS‑виртуализации)
- `config/propulsion/thrusters.json` — **геометрия и лимиты RCS сопел** (16 thrusters, позиция/направление/Fmax)

---

## 2) Проблема, которую решаем

Сейчас:
- в симуляции есть упрощённая “скорость/heading”, но **нет** честной модели RCS импульсов, топлива, пиковых нагрузок и ограничений;
- UI (ORION) не может отобразить RCS как “железо” без демо‑нулей/заглушек;
- Power/Thermal Plane уже существуют и должны стать **ограничителями** (PDU лимит, supercap, термозащита), но RCS пока не использует их.

Нужно:
- внедрить **минимально достаточную**, детерминированную модель RCS (STEP‑A), которая:
  - принимает команды манёвра,
  - распределяет их на 16 сопел (ZTT/FTG принципы),
  - генерирует telemetry по соплам/топливу/нагрузкам,
  - влияет на Power/Thermal (пики, троттлинг, нагрев) **без моков**.

---

## 3) Scope

### 3.1 Must‑have (обязательно в MVP)

1) **RCS model в симуляции (`q_sim_service`)**
   - поддержка RCS команд “манёвр по оси” минимум: `forward/aft/port/starboard` (дополнительно `up/down` — если уже есть в UI/командах);
   - команда задаётся процентом тяги `0..100` и длительностью (`timeout_ms`);
   - симуляция рассчитывает:
     - текущую активность RCS,
     - распределение по соплам (duty/valve on/off),
     - расход топлива/пропелланта,
     - потребляемую мощность и тепловыделение.

2) **Распределение тяги (allocator)**
   - из 16 сопел формируется “allocation”:
     - **ZTT** (Zero‑Torque Translation) для чистого перемещения (минимальный момент, близкий к нулю),
     - **FTG** (Full Thrust Group) — симметричный набор (если нужен режим “максимум”).
   - allocator не должен требовать SciPy/CVX‑зависимостей (MVP должен работать в текущем окружении).

3) **Единый источник параметров**
   - параметры RCS‑виртуализации (топливо, ISP, power budget, PWPF/PWM параметры, допуски) живут в `bot_config.json`;
   - список сопел **не копируется** — берётся только из `config/propulsion/thrusters.json`.

4) **Power/Thermal интеграция (без моков)**
   - RCS добавляет нагрузку в Power Plane:
     - при превышении лимита PDU (bus current) или при активном load shedding — RCS должен быть реально троттлен/ограничен;
     - пики (импульсность) должны использовать supercap при наличии бюджета (как минимум: расход `supercap_discharge_w` растёт при импульсе).
   - RCS добавляет тепло в Thermal Plane:
     - минимум: нагрев `hull` (или выделенного узла, если он уже есть в профиле).

5) **Телеметрия (`qiki.telemetry`)**
   - новые поля добавлять **верхним уровнем**: `propulsion: {...}` (без изменения `PowerTelemetry`, `ThermalTelemetry`, чтобы не ломать строгие модели).
   - `propulsion.rcs` включает минимум:
     - `propellant_kg` (остаток),
     - `active` (bool),
     - `command` (ось/процент/оставшееся время),
     - `thrusters[]` (id/index/cluster + duty_pct + status),
     - `net_force_n` и `net_torque` (для диагностики),
     - `power_w` (текущая нагрузка RCS).
   - если данных нет (не включено / нет профиля / файл не найден) → UI показывает `N/A`, а не “0”.

6) **ORION UI (no‑mocks)**
   - добавить экран/таблицу “Propulsion/RCS” (или секцию в Diagnostics) с данными из телеметрии:
     - список сопел, активность, расход топлива, power_w, троттлинг (если виден),
     - статус `OK/WARN/FAIL/N/A`.
   - никаких имитаций “прогресс‑баров” без источника: либо данные есть, либо `N/A`.

7) **Тесты**
   - unit‑тесты в `q_sim_service`:
     - валидатор `thrusters.json` (16 штук, направления нормированы),
     - `thruster_allocation_rank == 6` (для набора 16),
     - при команде RCS расход топлива уменьшается,
     - при PDU‑лимите/thermal trip RCS реально троттлится/блокируется (MVP минимум — троттлинг).

---

## 4) Термины и сущности

**Thruster** — сопло RCS: позиция, направление, max thrust.  
**Duty cycle** — доля времени “клапан открыт” в окне PWM/PWPF.  
**PWM/PWPF** — модуляция “вкл/выкл” для приближения к непрерывной тяге при on/off‑соплах.  
**Allocator** — функция, которая подбирает набор сопел и duty для достижения требуемой силы/момента.

---

## 5) Предлагаемая модель (MVP, детерминированная)

### 5.1. Allocator без тяжёлых зависимостей

MVP допускает один из двух подходов (выбрать один, не оба):

**A) Предвычисленные ZTT‑группы (рекомендуемо для MVP):**
- по `thrusters.json` заранее перебрать комбинации 2‑х и/или 4‑х сопел и выбрать лучший набор для каждой оси перемещения:
  - максимизировать проекцию силы на требуемую ось,
  - минимизировать норму момента (порог “почти ноль”).
- на тике симуляции применять масштабирование duty до требуемого процента.

**B) Лёгкий constrained least squares:**
- сформировать 6×N матрицу `A` (силы + моменты), решить “мягкое” LS и затем проектировать в `[0,1]` с итерацией.
- важно: не добавлять SciPy, использовать только `numpy` + простой актив‑сет/итерационный метод.

### 5.2. PWPF/PWM (упрощённо)

Сопла — on/off. В симуляции допустимо:
- хранить `duty_pct` как “идеальный” duty;
- по “окну” `pulse_window_s` выдавать `valve_open` (bool) детерминированно (например, по фазе `sim_time_s mod window`) — чтобы пики были видны в power/supercap.

### 5.3. Топливо/пропеллант (MVP)

Расход на шаге `dt`:
- `mdot = F_total / (Isp * g0)`  
- `m_used = mdot * dt`  
где `F_total` — суммарная тяга активных сопел (Н), `g0 = 9.80665`.

Если топлива нет → `active=false`, duty=0, и в диагностике фиксируется причина.

---

## 6) Параметры в `bot_config.json` (без дублей)

Добавить в `hardware_profile` секцию (пример):

- `propulsion_plane.enabled: bool`
- `propulsion_plane.thrusters_path: str` (например `"config/propulsion/thrusters.json"`)
- `propulsion_plane.propellant_kg_init: float`
- `propulsion_plane.isp_s: float`
- `propulsion_plane.rcs_power_w_at_100pct: float` (или `rcs_w_per_newton`)
- `propulsion_plane.heat_fraction_to_hull: float` (0..1)
- `propulsion_plane.pulse_window_s: float` (для импульсности)
- `propulsion_plane.ztt_torque_tol: float` (допуск момента для “почти ноль”)

Важно: список 16 сопел **не копировать** в `bot_config.json`.

---

## 7) Критерии приёмки (DoD)

Считаем задачу выполненной, если:
1) В Docker‑стеке `phase1` симуляция публикует телеметрию с `propulsion.rcs.*` (не пустышка, реальные вычисления).
2) ORION отображает RCS без моков: данные или `N/A`.
3) `pytest` для `q_sim_service` зелёный, есть тесты на валидность thrusters и базовые эффекты.
4) Не добавлены `*_v2.*`, не создано дублирующих источников правды.

---

## 8) References (для обсуждения подхода, не SoT проекта)

- “Thruster allocation” / force‑torque allocation (обзор подходов LS/active‑set): AIAA SciTech 2013 *Efficient Thruster Allocation Algorithms for Reaction Control Systems*.
- PWPF (pulse‑width pulse‑frequency) как классический модульатор для on/off‑актуаторов: IEEE paper *Pulse‑Width Pulse‑Frequency Modulator for Control of On‑Off Thrusters* (пример практики RCS PWM/PWPF).
