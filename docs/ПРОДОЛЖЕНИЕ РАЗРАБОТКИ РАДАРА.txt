1. Формат данных

Мы опирались на существующие стандарты из ROS/Autoware (radar_msgs) и морских пакетов (marine_sensor_msgs):

RadarReturn: range, azimuth, elevation, doppler_velocity, amplitude.

RadarTrack: готовые объекты с позицией, скоростью, вероятностью.

RadarScan: пачка детекций за тик.

Marine RadarSector/Echo: секторы и интенсивности отражений.

Это даёт гибкость: можно хранить как «сырые точки» (детекции), так и «треки» (объекты, уже пройденные фильтрацией).

2. Интеграция в проект

У тебя уже есть связка gRPC + NATS + FastStream + Pydantic v2:

gRPC — симулятор отдаёт сенсорные данные (GrpcDataProvider).

NATS/FastStream — событийный обмен командами и телеметрией, с автоматической сериализацией моделей.

Pydantic v2 — для строгих схем и сериализации/десериализации.

Добавление радара = новые модели (RadarReading, RadarTrack) в shared.models.core и новые маршруты (темы) в FastStream. Pydantic v2 позволит чётко валидировать поля (model_config, field_validator).

3. Классификация

Чтобы радар был понятен и боту, и оператору, мы заложили простую схему:

Пространственная ось: выше / ниже (±Z), ближе / дальше (range), левее / правее (azimuth).

Тип объекта: «неизвестный», «бот», «оператор», «станция», «угроза» и т. д.

Идентификатор: UUID или транспондерный код.

Вывод — в виде таблички/списка объектов, обновляемой динамически. Для ASCII-интерфейса можно отображать «+» для объектов выше, «-» для ниже, рядом диапазон и id.

4. Транспондер

Добавляем ещё один слой логики:

ON — объект публикует свой ID и тип в канал (NATS). Видим и на радаре, и в «свой-чужой».

OFF — объект скрывает свои метки, но первичный радар всё равно видит отражение (range/azimuth). Это даёт тактическое пространство: можно «притвориться камнем», но невидимым не станешь.

Modes (расширение): silent (минимум инфо), spoof (ложные данные), normal.

5. Причинно-следственная логика

Почему именно так:

ROS/Autoware форматы — проверенные, не изобретаем велосипед.

Pydantic v2 — чтобы гарантировать схему и совместимость с FastStream.

NATS — естественный канал для публикации пачек детекций и треков.

Классификация — минималистичная, но расширяемая; понятно и боту (для FSM), и оператору (в таблице).

Транспондер — реализм и тактическая вариативность, как в авиации: выключил — тебя всё равно видно, но уже без ярлыка.

6. Что делать дальше

Добавить в shared.models Pydantic-модели RadarDetection, RadarTrack, RadarScan.

Обновить GrpcDataProvider, чтобы он генерировал/принимал такие данные.

Создать FastStream-тему qiki.sensors.radar.scan.

В ядре агента подключить подписку на эти данные и прокидывать их в FSM/WorldModel.

Реализовать модуль «Transponder» с возможностью включить/выключить и логикой отображения.

В интерфейсе сделать табличный вывод с классификацией.

Хочешь, я соберу из этого финальный технический чек-лист в стиле «вот список файлов, какие правки и где внести», чтобы можно было сразу давать на реализацию?

Вы сказали:
RADAR.md
Файл
ВОТ КАК ОН РЕАЛЕЗОВАН
ChatGPT сказал:
Думал на протяжении 19s

Ну вот, наконец-то не догадки, а факты. По твоему досье радар уже поднят end-to-end: proto/gRPC/AsyncAPI, Pydantic v2 модели, симулятор генерит кадры, FastStream бридж делает минимальную агрегацию в треки, JetStream заведён, Phase-1 docker-компоуз встал, интеграционные тесты зелёные. 

RADAR

Что уже сделано по сути

Контракты: SensorType.RADAR, RadarDetection/Frame/Track, oneof radar_data|radar_track в SensorReading, gRPC GetRadarFrame.

Модели: строгие Pydantic v2 (extra=forbid, валидаторы углов/диапазонов), Proto↔Pydantic конвертеры.

Пайплайн: Q-Sim публикует кадры в JetStream (qiki.radar.v1.frames), FastStream-хендлер делает «первый трек» и шлёт в qiki.radar.v1.tracks.

Операции: JS-инициализатор, дедуп по Nats-Msg-Id, health-checks, юнит/интеграционные тесты, линтеры.

Статус: Phase-1 стек рабочий, E2E тесты проходят. 

RADAR

Переводя с инженерского: базовый контур готов и не разваливается под руками. Молодец, не зря сервер крутится.

Где «тонко» и что добить

Трекинг вместо заглушки. Сейчас frame_to_track() берет первую детекцию и лепит трек с quality=0.5. Нужен stateful трекер: ассоциация (NN/KF/JIPDA), фильтр (α-β или EKF), переидентификация, качество трека и life-cycle. 

RADAR

IFF/транспондер. В протоколе место под IFF есть, но логика поведения (ON/OFF/silent/spoof), правила конфликтов, приоритеты и аудиторский след не описаны.

Классификация и правила для FSM. Маппинг «объект-класс» → «решение» пока не формализован. Нужна таблица guard-условий и action-policy на уровне агента.

Наблюдаемость. Нет метрик по латентности, потере кадров, заполнению потоков, p95 по обработке. Придётся прикрутить Prometheus/Otel. 

RADAR

Нагрузка/Backpressure. Есть JetStream лимиты и ack-параметры, но нет результатов стресс-профилей, ни адаптивного понижения частоты кадров.

UI/терминал. Визуализация умышленно вне Phase-1. Для твоей «таблички с плюсами/минусами» надо отдать нормированный DTO и простой рендер.

Безопасность. Phase-1 — без ролей/скоупов. Под GPT-контролёр и оператора понадобятся скоупы на чтение/запись, аудит действий. 

RADAR

Как докрутить до «боеспособно сейчас»

Минимальный план Phase-2 без слёта архитектуры:

Трекинг (stateful)

Ввести TrackStore в FastStream-бридже: KF/EKF на полярных, gating по Махаланобису, пропуски/потеря, score/quality.

Схема: RadarTrack{track_id, pos, vel, radial_v, quality∈[0,1], class, iff}; обновление раз в тик, ретеншн 3–5 с.

IFF/транспондер

Политики: ON|OFF|SILENT|SPOOF. При OFF трек виден радаром, но без IFF-меток; при SPOOF — отдельный subject для расследований.

Логика слияния: если IFF есть и трек рядом в окне по дальности/азимуту — связываем, иначе помечаем «unknown».

Правила для FSM/тактики

Таблица guard-условий: например, unknown@<R 50m & bearing in danger_sector -> state=EVADE, friend@R<10m -> yield, spoof_detected -> alert.

Экспорт допустимых переходов для внешнего контролёра (QIKI/GPT) через NATS-тему qiki.fsm.transitions.

Наблюдаемость и профили

Prometheus экспорт: время генерации кадра, публикации, обработки, p95/p99, dropped frames, JS lag, consumer pending.

Нагрузочные тесты: 5× частота кадров, 10× количество отметок, деградационные режимы (понижаем частоту и размер кадра).

Терминальный UI

DTO RadarTableRow{signZ, range_m, az_deg, elev_deg, vr_mps, class, iff, quality, track_id}; сортировка по дальности; обновление 4–8 Гц.

Легенда: + выше, - ниже, ! опасно, ? unknown, цвет/иконки — по возможностям терминала.

Доступ и аудит

Ввести OAuth-скоупы для действий радара (read/tracks, write/transponder), журналирование всех команд с who/when/why/context.

Почему так (причины, не «просто хочется»)

Слои не ломаем. Контракты уже есть и работают; трекинг/IFF — надстройка на FastStream-уровне без переделки proto. 

RADAR

Надёжность. JetStream уже сконфигурен для дедупа и ретеншна; stateful-трекинг ложится поверх с нормальными ack/lag-метриками.

Прозрачность. Pydantic v2 гарантирует схему; валидаторы уже на месте — добавляем только логику.

Оперуправление. Табличный UI в терминале даёт мгновенную ситуационку; правила FSM формализуют «что делать дальше».

Микро-чек-лист на ближайшие коммиты

 services/faststream_bridge/radar_handlers.py: заменить frame_to_track() на stateful-трекинг, ввести TrackStore.

 shared/models/radar.py: расширить RadarTrackModel полями quality, class, iff_mode.

 services/q_core_agent: подписка на qiki.radar.v1.tracks, маппинг в WorldModel, guard-правила → FSM.

 services/q_core_agent/ui: простой renderer терминальной таблицы по DTO.

 observability/: экспортер метрик + дашборд.

 tests/integration/*: сценарии с потерей кадров, всплесками, spoof/IFF, проверка guard-переходов.

 docs/asyncapi/radar_v1.yaml: дополняем схемы треков/IFF и публикуем артефакт. 

RADAR

Если кратко: фундамент у тебя уже стоит и стоит ровно. Осталось вселить в него мозги трекинга, дисциплину транспондера и глаза оператора. Тогда радар перестанет быть «проводом в воздух» и станет нормальным тактическим органом чувств.

Источники
Вы сказали:
проверь себя в интернете
ChatGPT сказал:

Да — я проверил себя и детали проекта по радару с источниками в интернете, чтобы убедиться, что твой подход соответствует практике и теориям. Вот результаты проверки + уточнения + коррекции, если нужно.

Что подтвердилось в интернете

radar_msgs (ROS)
Существует стандартный пакет сообщений для радаров в ROS — radar_msgs. Там есть категория Detections (сырые отражения) и Tracks (отслеженные объекты). Это соответствует тому, что мы планируем: иметь и «сырые» и «трековые» данные. 
wiki.ros.org
+1

Primary vs Secondary Radar и Транспондеры

Primary Radar (PSR) — обнаруживает объекты без участия самой цели. То есть, даже если цель «спит» и не передаёт, отражение будет. 
Википедия
+2
faa.gov
+2

Secondary Radar / Транспондер (SSR / IFF) — требует, чтобы цель имела устройство-ответчик, которое реагирует, передаёт идентификатор, возможно высоту. Без транспондера идентификатор не будет, но цель может всё равно быть замечена первичным. 
radartutorial.eu
+2
Study Aircrafts
+2

Исследования по mmWave радару в робототехнике
Недавние обзоры показывают, что радары mmWave активно используются для задач, где лидары и камеры слабее — плохая видимость, запылённость и т.п. Они дают хорошие отражения по дальности, скорости, устойчивость к погоде, но сложнее классифицировать тип цели без дополнительных сенсоров. 
arXiv

Предложения по стандартизациям
Сообщество (ROS / marine sensor groups) предлагает совместимые схемы сообщений, в которых radar_scan / radar_sector / target_track стандартно включают поля: range, azimuth, elevation, velocity, amplitude / intensity / signal_strength и опционально classification / id. 
Open Robotics Discourse
+1

Логика транспондера / IFF
Интернет-материалы подтверждают, что концепция транспондера — это активный ответ, обеспечивающий идентификацию, и что Primary Radar может видеть цели без транспондера. Это полностью совпадает с тем, что ты хочешь: транспондер может быть выключен, но отражения видны.

Что стоит скорректировать/дополнить на основе проверки

Если ты планируешь классификацию целей: «бот», «оператор», «станция» и др., придётся либо иметь обученную модель, либо правила на основе IFF / типа цели / сигнала. Интернет показывает, что часто классификация смущается без IFF / метки / визуальных признаков. То есть правило “если нет транспондера, ставим class=unknown” — разумно.

Задержка и объём данных: обзоры mmWave показывают, что где-то с 600-800 МГц каналов, обработкой 3-D или 4-D данных (включая допплер) нагрузка выше и задержки могут быть значимыми. Если частота кадров выше 10-20 Гц или если ты шлёшь большие массивы данных, можно сильно загрузить систему.

Точность углов и высоты: многие сообщения ROS/radar_msgs не включают высоту/элевацию, или делают это опционально / с погрешностью. Если тебе важно «высоко-ниже», нужно обеспечить датчик, способный высоту/элевацию (или вычислять через наклон, стояние на платформе и т.п.).

Заключение по проверке

То, как ты задумал систему, отражается в практиках, которые уже используются в робототехнике и авиации:

использование Primary Radar + Secondary Radar / транспондера;

наличие неотслеженных отражений и отслеженных треков;

классификация через IFF или метки, если есть, иначе «unknown»;

формат сообщений и поля, которые ты предлагаешь — совпадают с тем, что предлагают стандарты.

Поэтому твоя модель соответствует “best practices” и не противоречит известным источникам.

Коротко: да, задача — добить то, что уже есть, и внести точечные исправления. Ни переписывать вселенную, ни выкидывать архитектуру не нужно. Вот финальный чек-лист «доделок» и фиксов с привязкой к тому, что доказуемо best-practice.

1) Данные радара: доводим до стандарта

Оставляем два уровня представления: детекции и треки. Структуры и поля сверяем с radar_msgs (range, azimuth, elevation, doppler, amplitude; массив треков в RadarTracks). Это снимает вопросы совместимости и терминологии. 
ROS
+2
ROS
+2

Если используете собственные метки классов для треков — держим окно расширений по схеме Autoware (классы выше 32000). 
autowarefoundation.github.io

2) Pydantic v2: привести модели к единым правилам

Конфигурация в v2 задаётся через model_config, а валидаторы через @field_validator/@model_validator. Приводим все модели радара к единому стилю v2, без «артефактов» v1. 
docs.pydantic.dev
+2
docs.pydantic.dev
+2

Проверки диапазонов углов/дальностей и нормализация единиц измерения делаются валидаторами на поле/модель, чтобы мусор не пролетал в пайплайн. 
docs.pydantic.dev

3) FastStream/NATS: навести порядок в шине

Закрепляем FastStream как слой подписок/публикаций (AsyncAPI автодоки, типизация, валидация входа/выхода). Это снижает «ад-hoc» код вокруг NATS. 
NATS.io
+2
faststream.ag2.ai
+2

Для JetStream настраиваем потребителей с учётом MaxAckPending/AckWait и выбираем режим pull/push по профилю нагрузки. Это фиксит «подвисания» и дубликаты при внешних задержках (например, когда решения приходят от GPT). 
docs.nats.io
+3
docs.nats.io
+3
docs.nats.io
+3

4) Трекинг: вместо заглушки — stateful

Меняем «first-hit → track» на нормальный stateful трекинг: ассоциация по окну/доплеру, KF/EKF, счётчики жизни, quality∈[0..1]. Интерфейс оставляем совместимым с RadarTrack[], чтобы отображение и FSM не ломались. Основание — разделение detections vs tracks как в ROS. 
ROS

5) Транспондер/IFF: поведение, не только поля

Формализуем режимы: ON|OFF|SILENT|SPOOF. При OFF цель всё равно видна первичным радаром, но без идентификатора; это нормальная модель из реального мира и геймдизайна. 
Open Robotics Discourse

Правила слияния: если IFF-метка в окне по дальности/азимуту — привязываем к треку; иначе класс unknown. Это же рекомендуют автопилотные стеки: метаданные класса поверх базовой геометрии. 
autowarefoundation.github.io

6) FSM/тактика: явные guard-условия

Выносим таблицу guard-правил: «опасный сектор + неизвестный + R<Х → EVADE», «friend R<Y → YIELD», «спуф → ALERT». Переходы публикуем в тему «transitions», чтобы QIKI/оператор их видели. Под это уже есть транспорт и модели — просто доводим. 
NATS.io

7) Наблюдаемость и SLA

Метрики JetStream: задержка публикации/потребления, redeliveries, lag, p95/p99; alarms при просадке ack’ов. Это рекомендуют официальные гайды JetStream. 
docs.nats.io
+1

SLA для QIKI-цикла: p50 ≤ 500 мс, p95 ≤ 1500 мс; при тайм-ауте выполняем локальный safe-plan без ожидания. Это укладывается в сетевую и инференсную экономику.

Что именно «доделать» сейчас, по шагам

Причесать Pydantic-модели радара под v2 (config/валидаторы), синхронно обновить AsyncAPI. 
docs.pydantic.dev
+1

Переконфигурировать JetStream-консьюмеров: MaxAckPending, AckWait, режим pull для тяжёлых обработчиков; включить exactly-once (dedup + double ack) там, где критично. 
docs.nats.io
+1

Заменить «заглушку» трекинга на KF/EKF-базовый TrackStore с ассоциацией и quality-скором; интерфейс оставить RadarTracks. 
ROS

Оформить IFF/транспондер: режимы, правила слияния, аудит команд. 
Open Robotics Discourse

Внести guard-таблицу в FSM и публиковать доступные переходы для QIKI/оператора через FastStream. 
NATS.io

Добавить метрики и тревоги по шине и обработчикам (Prometheus/экспортеры). 
docs.nats.io

Да, именно это и надо «доделать + подправить». Не героизм, а аккуратная инженерия: привести модели к стандарту, стабилизировать шину, сделать нормальный трекинг и формализовать IFF/guard-правила. После этого радар перестанет быть просто «датчиком» и станет тактическим органом, понятным и боту, и вам.

