import os
import re
import subprocess
import shutil
import logging
from pathlib import Path
from jinja2 import Environment, FileSystemLoader

# Настройка логирования для generator.py
logger = logging.getLogger(__name__)

# Определяем пути (пока как константы, с прицелом на config.yaml)
_CURRENT_DIR = Path(os.path.dirname(__file__))
_TOOL_ROOT = _CURRENT_DIR.parent
_PROJECT_ROOT = _TOOL_ROOT.parent.parent # /data/data/com.termux/files/home/QIKI_DTMP
_TEMPLATE_DIR = _TOOL_ROOT / 'templates'
_PROTOS_DIR = _PROJECT_ROOT / 'protos'
_GENERATED_DIR = _PROJECT_ROOT / 'generated'
_DOCS_DESIGN_DIR = _PROJECT_ROOT / 'docs' / 'design'

_ENV = Environment(loader=FileSystemLoader(str(_TEMPLATE_DIR)))

def to_snake_case(name: str) -> str:
    """Конвертирует имя компонента в snake_case."""
    s1 = re.sub('(.)([A-Z][a-z]+)', r'\1_\2', name)
    return re.sub('([a-z0-9])([A-Z])', r'\1_\2', s1).lower().replace('-', '_')

def create_design_document(component_name: str, target_path: str, force: bool = False, dry_run: bool = False, template_name: str = "default"):
    """
    Создает design.md документ для нового компонента.
    """
    target_path_obj = Path(target_path)
    if target_path_obj.exists() and not force:
        logger.error(f"Файл '{target_path_obj}' уже существует. Используйте --force для перезаписи.")
        return

    try:
        template = _ENV.get_template(f"{template_name}_design.md.template")
        rendered_content = template.render(component_name=component_name)
        
        if dry_run:
            logger.info(f"Dry Run: Документ '{target_path_obj}' будет создан.\n--- Содержимое ---\n{rendered_content}\n---")
        else:
            target_path_obj.parent.mkdir(parents=True, exist_ok=True)
            with open(target_path_obj, "w", encoding="utf-8") as f:
                f.write(rendered_content)
            logger.info(f"Документ '{target_path_obj}' успешно создан.")
    except Exception as e:
        logger.error(f"Ошибка при создании документа {target_path_obj}: {e}", exc_info=True)

def create_proto_contract(component_name: str, force: bool = False, dry_run: bool = False, template_name: str = "default"):
    """Создает .proto контракт для нового компонента."""
    snake_name = to_snake_case(component_name)
    proto_type_name = "".join(word.capitalize() for word in snake_name.split('_')) + "Message"
    target_path_obj = _PROTOS_DIR / f"{snake_name}.proto"

    if target_path_obj.exists() and not force:
        logger.error(f"Файл '{target_path_obj}' уже существует. Используйте --force для перезаписи.")
        return

    try:
        template = _ENV.get_template(f"{template_name}_component.proto.template")
        rendered_content = template.render(
            component_name=snake_name,
            component_proto_type=proto_type_name
        )
        
        if dry_run:
            logger.info(f"Dry Run: Контракт '{target_path_obj}' будет создан.\n--- Содержимое ---\n{rendered_content}\n---")
        else:
            with open(target_path_obj, "w", encoding="utf-8") as f:
                f.write(rendered_content)
            logger.info(f"Контракт '{target_path_obj}' успешно создан.")
    except Exception as e:
        logger.error(f"Ошибка при создании контракта {target_path_obj}: {e}", exc_info=True)

def compile_protos(dry_run: bool = False):
    """Компилирует все .proto файлы в директории protos/."""
    if not shutil.which("protoc"):
        logger.error("Компилятор `protoc` не найден. Убедитесь, что он установлен и находится в PATH.")
        return

    if not dry_run:
        if _GENERATED_DIR.exists():
            shutil.rmtree(str(_GENERATED_DIR))
        _GENERATED_DIR.mkdir(parents=True)
        # Создаем __init__.py, чтобы generated была пакетом
        (_GENERATED_DIR / "__init__.py").write_text("# Auto-generated by qiki-docgen\n")

    proto_files = [f for f in os.listdir(str(_PROTOS_DIR)) if f.endswith('.proto')]
    if not proto_files:
        logger.warning(" .proto файлы не найдены в директории protos/.")
        return

    command = [
        "protoc",
        f"-I={_PROTOS_DIR}",
        f"-I=/data/data/com.termux/files/usr/include", # Путь для Termux
        f"--python_out={_GENERATED_DIR}",
    ] + [str(_PROTOS_DIR / f) for f in proto_files]

    logger.info(f"Запуск компиляции: {' '.join(command)}")
    if dry_run:
        logger.info("Dry Run: Компиляция Protobuf будет выполнена.")
        return

    result = subprocess.run(command, capture_output=True, text=True, check=False) # check=False для ручной обработки ошибок

    if result.returncode != 0:
        logger.error(f"Ошибка компиляции Protobuf:\n{result.stderr}")
        raise RuntimeError("Protobuf compilation failed.")
    else:
        logger.info("Все .proto файлы успешно скомпилированы.")

def build_readme(dry_run: bool = False):
    """Собирает главный README.md из дизайн-документов компонентов."""
    components = []

    if not _DOCS_DESIGN_DIR.exists():
        logger.warning(f"Директория дизайн-документов не найдена: {_DOCS_DESIGN_DIR}")
        return

    for component_dir in _DOCS_DESIGN_DIR.iterdir():
        if component_dir.is_dir():
            design_file = component_dir / f"{component_dir.name}_design.md"
            if design_file.exists():
                try:
                    content = design_file.read_text(encoding='utf-8')
                    # Простой парсинг для извлечения раздела "1. Обзор"
                    overview_match = re.search(r"## 1\\. Обзор\\n(.*?)(?:\\n## |$)", content, re.DOTALL)
                    overview_text = overview_match.group(1).strip() if overview_match else "Обзор не найден."
                    
                    components.append({
                        'name': component_dir.name,
                        'overview': overview_text,
                        'path': str(design_file.relative_to(_PROJECT_ROOT))
                    })
                except Exception as e:
                    logger.error(f"Ошибка при чтении файла {design_file}: {e}", exc_info=True)

    try:
        template = _ENV.get_template("README.md.template")
        rendered_content = template.render(components=components)
        target_path_obj = _PROJECT_ROOT / "README.md"

        if dry_run:
            logger.info(f"Dry Run: Главный README.md будет обновлен.\n--- Содержимое ---\n{rendered_content}\n---")
        else:
            target_path_obj.write_text(rendered_content, encoding="utf-8")
            logger.info(f"Главный README.md успешно обновлен.")
    except Exception as e:
        logger.error(f"Ошибка при сборке README.md: {e}", exc_info=True)
